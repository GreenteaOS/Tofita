// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

Bitmap32 *loadPng32FromBuffer(data: Pointer<UInt8>, size: UInt32) {
	Int32 width, height, png_bpp
@deep
@noGenerate
declare fun stbi_load_from_memory(
	data: Pointer<UInt8>,
	size: UInt32,
	width: Pointer<Int32>,
	height: Pointer<Int32>,
	png_bpp: Pointer<Int32>,
	bytes: Int32
): Pointer<UInt8>

	var colors: Pointer<UInt8> = stbi_load_from_memory(data, size, Pointer.of(width), Pointer.of(height), Pointer.of(png_bpp), 4)
	var bitmap: Pointer<Bitmap32> = allocateBitmap(width, height)

	var rgba: Pointer<UInt32> = colors as! Pointer<UInt32>
	for y in height {
		for x in width {
			bitmap.pixels[y * width + x].color = rgba[y * width + x]
			// This should be fixed in framebuffer? Or PNG really BGRA?
			var temp: UInt8 = bitmap.pixels[y * width + x].rgba.r
			bitmap.pixels[y * width + x].rgba.r = bitmap.pixels[y * width + x].rgba.b
			bitmap.pixels[y * width + x].rgba.b = temp
		}
	}

	return bitmap
}

fun loadPng32(asset: RamDiskAsset): Bitmap32 {
	return loadPng32FromBuffer(asset.data, asset.size)
}
