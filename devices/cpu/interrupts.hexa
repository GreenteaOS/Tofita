// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

let pic1 = 0x20u8 // io base address for main pic
let pic2 = 0xa0u8 // io base address for secondary pic
let pic1_command = pic1
let pic1_command_0x20 = 0x20u16
let pic1_data = (pic1 + 1)
let pic2_command = pic2
let pic2_data = (pic2 + 1)
let pic_eoi = 0x20u8	  // end-of-interrupt command code
let pic_eoi_0x20 = 0x20u8 // end-of-interrupt command code

@rename('vmemcpy')
declare fun tmemcpy(dest: ArrayPointer<UInt8>, src: ConstArrayPointer<UInt8>, count: UInt64): Void
/* {
	for i in count {
		dest[0] = src[0]
	}
}*/

@rename('vmemcpy')
declare fun vmemcpy(@volatile dest: ArrayPointer<UInt8>, @volatile src: ConstArrayPointer<UInt8>, @volatile count: UInt64): Void
/* {
	for i in count {
		dest[0] = src[0]
	}
}*/

@struct @packed @sizeOf(10)
@rename('Idtr')
@asIs
declare
class Idtr {
	var limit: UInt16
	var offset: UInt64
	new ()
}

@struct @packed
class IdtEntry {
	@bits(16) var offsetLowerBits: UInt16
	@bits(16) var selector: UInt16
	@bits(8) var ist: UInt8
	@bits(4) var gateType: UInt8
	@bits(1) var z: UInt8
	@bits(2) var dpl: UInt8
	@bits(1) var present: UInt8
	@bits(48) var offsetHigherBits: UInt64
	@bits(32) var zero: UInt32
}

fun readPort(@volatile port: UInt16): UInt8 {
	return portInb(port)
}

fun writePort(@volatile port: UInt16, @volatile value: UInt8) {
	portOutb(port, value)
}

@emitHeader @linkAsIs
declare fun loadIdt(@volatile idtr: Idtr): Void

enum Selector : UInt64 {
	SYS_CODE64_SEL = 0x10 // Execute/Read
	SYS_DATA32_SEL = 0x18 // Read/Write
	NULL_SEL = 0x00
	USER_CODE32_SEL = 0x20 // Execute/Read
	USER_DATA32_SEL = 0x28 // Read/Write
	USER_CODE64_SEL = 0x30 // Execute/Read
	SYS_CODE32_SEL = 0x60 // Execute/Read

	// Just `+ 3` to above selectors
	// TODO allow `0x30 + 3` in enum tags
	USER_CODE64_SEL_USER_MODE = 0x33 // Execute/Read/UserNode
	USER_DATA32_SEL_USER_MODE = 0x2b // Read/Write/UserNode
}

// Handling IDT
let idt_size = 256
// Records of the GDT - 16 items
//let empty_sel = 0x08
// Layout expected by SYSRET
//let empty_sel = 0x38
//let tss_sel = 0x40 // Index = 8
//let tss_sel = 0x48
//let user_data32_sel = 0x50 // Read/Write
//let empty_sel = 0x58
//let empty_sel = 0x68
//let empty_sel = 0x70
//let empty_sel = 0x78

// TODO IdtEntry IDT[idt_size]
var idt: ArrayByValue<ByValue<IdtEntry>, 256> = []

// Handling keyboard interrupts
@rename('keyboardHandler')
@extern declare fun keyboardHandler(): Void
fun initializeKeyboard(entry: IdtEntry) {
	var keyboardAddress: UInt64 = ((keyboardHandler as! UInt64))
	entry.offsetLowerBits = keyboardAddress & 0xFFFFu16
	entry.offsetHigherBits = (keyboardAddress & 0xFFFFFFFFFFFF0000u64) >> 16
	entry.selector = Selector.SYS_CODE64_SEL as! UInt16
	entry.zero = 0
	entry.ist = 2 // Stack
	entry.z = 0
	entry.dpl = 0 // Ring 0
	entry.present = 1
	entry.gateType = 0xE // Interrupt gate
	// TODO fix vscode: 0xe is invalid, valid only oxE
}

// Handling mouse interrupts
@rename('mouseHandler')
@linkName('mouseHandler')
declare fun mouseHandler(): Void
fun initializeMouse(entry: IdtEntry) {
	var mouseAddress: UInt64 = ((mouseHandler as! UInt64))
	entry.offsetLowerBits = mouseAddress & 0xFFFFu16
	entry.offsetHigherBits = (mouseAddress & 0xFFFFFFFFFFFF0000u64) >> 16
	entry.selector = Selector.SYS_CODE64_SEL as! UInt16
	entry.zero = 0
	entry.ist = 2 // Stack
	entry.z = 0
	entry.dpl = 0 // Ring 0
	entry.present = 1
	entry.gateType = 0xE // Interrupt gate
}

// Handling interrupts and exceptions
fun initializeCallback(entry: IdtEntry, fallbackHandler: UInt64) {
	var address: UInt64 = ((fallbackHandler as! UInt64))
	entry.offsetLowerBits = address & 0xFFFFu16
	entry.offsetHigherBits = (address & 0xFFFFFFFFFFFF0000u64) >> 16
	entry.selector = Selector.SYS_CODE64_SEL as! UInt16
	entry.zero = 0
	entry.ist = 1 // Stack
	entry.z = 0
	entry.dpl = 3 // Ring 3
	entry.present = 1
	entry.gateType = 0xE // Interrupt gate
}

// PIC http://wiki.osdev.org/8259_PIC
// TODO move to separate module
fun remapPic() {
	serialPrintln("[cpu] begin: remap PIC")

	writePort(0x20, 0x11)
	writePort(0xA0, 0x11)
	writePort(0x21, 0x20)
	writePort(0xA1, 0x28)
	writePort(0x21, 0x04)
	writePort(0xA1, 0x02)
	writePort(0x21, 0x01)
	writePort(0xA1, 0x01)
	writePort(0x21, 0x0)
	writePort(0xA1, 0x0)

	serialPrintln("[cpu] done: remap PIC")
}

// Sets up the legacy PIC and then disables it
fun disablePic() {
	serialPrintln("[cpu] begin: disable PIC")

	/* Set ICW1 */
	writePort(0x20, 0x11)
	writePort(0xA0, 0x11)

	/* Set ICW2 (IRQ base offsets) */
	writePort(0x21, 0xE0)
	writePort(0xA1, 0xE8)

	/* Set ICW3 */
	writePort(0x21, 4)
	writePort(0xA1, 2)

	/* Set ICW4 */
	writePort(0x21, 1)
	writePort(0xA1, 1)

	/* Set OCW1 (interrupt masks) */
	writePort(0x21, 0xFF)
	writePort(0xA1, 0xFF)

	serialPrintln("[cpu] done: disable PIC")
}

fun physicalToVirtual(physical: UInt64): UInt64 {
	var result: UInt64 = (wholePhysicalStart as! UInt64) + (physical as! UInt64)
	return result
}

// TODO check for CPU feature
fun enableLocalApic() {
	serialPrintln("[cpu] begin: enableLocalApic")

	var ptr = physicalToVirtual(0xFEE000F0u32) as! ArrayPointer<UInt32>
	var val: UInt32 = ptr[0]
	quakePrintf("APIC value is %u\n".utf16(), val)

	serialPrintln("[cpu] done: enableLocalApic")
}

let irq0 = 32u16
let irq1 = 0x21u16 // 33
let irq2 = 34u16
let irq3 = 35u16
let irq4 = 36u16
let irq5 = 37u16
let irq6 = 38u16
let irq7 = 39u16
let irq8 = 40u16
let irq9 = 41u16
let irq10 = 42u16
let irq11 = 43u16
let irq12 = 44u16 // 2c
let irq13 = 45u16
let irq14 = 46u16
let irq15 = 47u16

@struct @packed @sizeOf(10)
@asIs // TODO
@rename('TablePtr')
declare class TablePtr {
	var limit: UInt16
	var base: UInt64
	new ()
}

@emitHeader @linkAsIs
declare fun lgdt(@volatile gdt: TablePtr): Void

// TODO @bitMask
enum GdtType : UInt8 {
	Accessed = 0x01
	Read_write = 0x02
	Conforming = 0x04
	Execute = 0x08
	System = 0x10
	Ring1 = 0x20
	Ring2 = 0x40
	Ring3 = 0x60
	Present = 0x80
}

@struct @packed @sizeOf(8)
class GdtDescriptor {
	var limitLow: UInt16
	var baseLow: UInt16
	var baseMid: UInt8
	var type: GdtType // Access
	var size: UInt8
	var baseHigh: UInt8
}

@struct @packed @sizeOf(8)
class GdtDescriptorEx {
	@bits(16) var limitLow: UInt16
	@bits(16) var baseLow: UInt16
	@bits(8) var baseMid: UInt8
	// Access
	@bits(1) var accessed: UInt8
	@bits(1) var rw: UInt8 // 0 - read, 1 - read/write
	@bits(1) var direction: UInt8 // or conform
	// If 1 code in this segment can be executed from an equal or lower privilege level
	// If 0 code in this segment can only be executed from the ring set in "privilege"
	@bits(1) var execute: UInt8 // 1 = code, 0 = data
	@bits(1) var one: UInt8
	@bits(2) var privilege: UInt8 // 0 = ring0/kernel, 3 = ring3
	@bits(1) var present: UInt8
	// Flags
	@bits(4) var limit: UInt8
	@bits(2) var reserved: UInt8
	@bits(1) var zero16one32: UInt8
	@bits(1) var blocks: UInt8

	@bits(8) var baseHigh: UInt8
}

@struct @packed
class TssDescriptor {
	var limitLow: UInt16
	var base_00: UInt16
	var base_16: UInt8
	var type: GdtType
	var size: UInt8
	var base_24: UInt8
	var base_32: UInt32
	var reserved: UInt32
}

@struct @packed
class TssEntry {
	var reserved0: UInt32

	var rsp: ArrayByValue<UInt64, 3> // stack pointers for CPL 0-2
	var ist: ArrayByValue<UInt64, 8> // ist[0] is reserved

	var reserved1: UInt64
	var reserved2: UInt16
	var iomap_offset: UInt16

	new () {}
}

@aligned(64) @volatile var globalGdtr: TablePtr = new TablePtr()
@aligned(64) @volatile var globalTss: TssEntry = new TssEntry()

// rsp0stack = exp0 in TSS
// Stack used by kernel to handle syscalls/interrupts
// `4096 * 32 = 131072`
// TODO `let`
@aligned(64) var rsp0stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var rsp1stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var rsp2stack: ArrayByValue<UInt8, 131072> = [0]

@aligned(64) var ist0stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist1stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist2stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist3stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist4stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist5stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist6stack: ArrayByValue<UInt8, 131072> = [0]
@aligned(64) var ist7stack: ArrayByValue<UInt8, 131072> = [0]

// LLVM did the magic expected of it. It only saved registers that are clobbered by your fun (hence rax).
// All other register are left unchanged hence thereâ€™s no need of saving and restoring them.
// https://github.com/phil-opp/blog_os/issues/450#issuecomment-582535783

// TODO: errcode is `extra` here:
//@aligned(64) @interrupt Void unknownInterrupt(struct frame: <InterruptFrame>,
// uint64_t
// extra) {
// https://github.com/llvm-mirror/clang/blob/master/test/SemaCXX/attr-x86-interrupt.cpp#L30
//declare fun anyInterruptHandler(frame: <InterruptFrame>): Void

// TODO remove
@aligned(64) @interrupt fun unknownInterrupt(frame: InterruptFrame): Void {
	// TODO Find a better way to avoid LLVM bugs
	anyInterruptHandler(frame)
}

fun anyInterruptHandler(frame: InterruptFrame): Void {
	disableAllInterrupts()
	#if false
		let stack = ((frame as! UInt64) - 200) as! InterruptStack
	#end

	// Enable interrupts
	writePort(0xA0, 0x20)
	writePort(pic1_command_0x20, pic_eoi_0x20)

	// Operating systems use some of the segments for internal usage.
	// For instance GS register to access the TLS (thread local storage)
}

// ~121 times per second
var timerCalled: UInt64 = 0

let stackSizeForKernelThread: UInt64 = 1024 * 1024u64

@aligned(64)
// TODO let
// TODO ArrayByValue cannot be `var`
var kernelStack: ArrayByValue<UInt8, 1048576> = [0]

var guiThreadFrame: InterruptFrame = new InterruptFrame()
@aligned(64)
var guiStack: ArrayByValue<UInt8, 1048576> = [0]

var extraMillisecond: UInt8 = 0
var taskBarRedraw: UInt8 = 0 // Re-paint task bar current time
@volatile var nextIsUserProcess: Bool = false
@volatile var nextIsGuiThread: Bool = true

fun getNextProcess(): UInt64 {
	var index: UInt64 = 1
	while index < 255 {
		if processes[index].present == true {
			if processes[index].schedulable == true {
				if processes[index].scheduleOnNextTick == true {
					return index
				}
			}
		}
		index++
	}

	return 0 // Idle
}

fun markAllProcessessSchedulable() {
	var index: UInt64 = 0
	while index < 255 { // TODO 256?
		if processes[index].present == true {
			if processes[index].schedulable == true {
				processes[index].scheduleOnNextTick = true
			}
		}
		index++
	}
}

fun switchToKernelThread(@volatile frame: InterruptFrame) {
	if currentThread == ThreadKind.THREAD_KERNEL {
		return
	}

	if currentThread == ThreadKind.THREAD_USER {
		// Save
		var process: UserProcess = processes[currentProcess]
		tmemcpy(process.frame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
	} else if currentThread == ThreadKind.THREAD_GUI {
		// Save
		tmemcpy(guiThreadFrame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
	}

	// Restore
	currentThread = ThreadKind.THREAD_KERNEL
	writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))
	tmemcpy(frame as! ArrayPointer<UInt8>, kernelThreadFrame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
}

fun switchToNextProcess(@volatile frame: InterruptFrame) {
	@volatile var next = getNextProcess()

	if next == 0 {
		markAllProcessessSchedulable()
		next = getNextProcess()
	}

	var process: UserProcess = processes[next]
	@volatile let old = currentProcess
	currentProcess = process.pid
	// TODO in .exe loader, disallow changing of CR3 until not fully loaded
	// another option is to save/restore CR3 used by kernel thread
	writeCr3((process.pml4 as! UInt64) - (wholePhysicalStart as! UInt64))
	process.scheduleOnNextTick = false

	// Note: pid 0 is not real process, so keep things in kernel
	if next != 0 {
		if currentThread == ThreadKind.THREAD_GUI {
			// Save
			tmemcpy(guiThreadFrame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
		} else if currentThread == ThreadKind.THREAD_USER {
			// Save
			var processOld: UserProcess = processes[old]
			tmemcpy(processOld.frame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
		} else if currentThread == ThreadKind.THREAD_KERNEL {
			// Save
			tmemcpy(kernelThreadFrame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
		}

		// Restore
		currentThread = ThreadKind.THREAD_USER
		tmemcpy(frame as! ArrayPointer<UInt8>, process.frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
	} else {
		writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))
		switchToKernelThread(frame)
	}
}

var kernelThreadBusy = false
fun switchToGuiThread(@volatile frame: InterruptFrame) {
	if currentThread == ThreadKind.THREAD_GUI {
		return
	}

	if currentThread == ThreadKind.THREAD_USER {
		// Save
		var process: UserProcess = processes[currentProcess]
		tmemcpy(process.frame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
	} else if currentThread == ThreadKind.THREAD_KERNEL {
		if kernelThreadBusy {
			return // Wait to avoid race conditions
		}
		// Save
		tmemcpy(kernelThreadFrame as! ArrayPointer<UInt8>, frame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
	}

	// Restore
	currentThread = ThreadKind.THREAD_GUI
	tmemcpy(frame as! ArrayPointer<UInt8>, guiThreadFrame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
}

fun yieldInterruptHandler(@volatile frame: InterruptFrame) {
	disableAllInterrupts()
	switchToNextProcess(frame)
}

fun timerInterruptHandler(@volatile frame: InterruptFrame) {
	disableAllInterrupts()

	if timerCalled % 121 == 0 {
		taskBarRedraw++
		if taskBarRedraw > 30 {
			haveToRender = true
			taskBarRedraw = 0
		}
	}
	uptimeMilliseconds += 8
	if extraMillisecond % 4 == 0 {
		uptimeMilliseconds += 1 // PIT is somewhat imprecise
	}
	if extraMillisecond % 64 == 0 {
		uptimeMilliseconds += 1 // PIT is somewhat imprecise
	}
	extraMillisecond++
	timerCalled++

	// Schedule
	if true {
		if currentThread == ThreadKind.THREAD_INIT {
			// TODO hexa error == statement: currentThread == THREAD_INIT
			guiThreadFrame.flags = frame.flags // TODO
			kernelThreadFrame.flags = frame.flags // TODO

			// Restore
			currentThread = ThreadKind.THREAD_GUI
			tmemcpy(frame as! ArrayPointer<UInt8>, guiThreadFrame as! ConstArrayPointer<UInt8>, sizeOf<InterruptFrame>())
		} else {
			if currentThread == ThreadKind.THREAD_GUI {
				// Just give it enough time to finish rendering
				// It will schedule to other process on finish
				nextIsGuiThread = false
			} else {
				if nextIsGuiThread == true {
					nextIsGuiThread = false
					switchToGuiThread(frame)
				} else {
					nextIsGuiThread = true
					if nextIsUserProcess == true {
						switchToKernelThread(frame)
					} else {
						switchToNextProcess(frame)
					}
					nextIsUserProcess = !nextIsUserProcess
				}
			}
		}
	}
	//		if currentThread == THREAD_INIT {
	//			// TODO hexa error == statement: currentThread == THREAD_INIT

	// Enable interrupts
	writePort(pic1_command_0x20, pic_eoi_0x20)
}

fun syscallInterruptHandler(frame: InterruptFrame) {
	disableAllInterrupts()
	@volatile let process: UserProcess = processes[currentProcess]
	process.schedulable = false
	@volatile let index = frame.rcxArg0 as! TofitaSyscalls

	// No-op
	if (index as! UInt64) < userSyscalls {
		process.schedulable = true
		return
	}

	process.syscallToHandle = index

	switchToKernelThread(frame)
	// TODO weird frame+8 offset if called switchToNextProcess
	// switchToNextProcess(frame)
	{
		return // TODO
	}

	if index == TofitaSyscalls.DebugLog {
		serialPrintf("[[DebugLog:PID %d]] %s\n", currentProcess, frame.rdxArg1)
		return
	}

	if index == TofitaSyscalls.ExitProcess {
		serialPrintf("[[ExitProcess:PID %d]] %d\n", currentProcess, frame.rdxArg1)
		// TODO kernel wakeup
		// TODO destroy process
		var process: UserProcess = processes[currentProcess]
		process.schedulable = false
		switchToNextProcess(frame)
		process.present = false
		return
	}
}

@emitHeader @linkAsIs
declare fun setTsr(@volatile tsrData: UInt16): Void

// 16 records
// TODO let
@aligned(64) var gdtTemplate: ArrayByValue<UInt32, 32> = [
	0x00000000u32, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00209B00, 0x0000FFFF, 0x00CF9300,
	0x0000FFFF, 0x00CFFA00, 0x0000FFFF, 0x00CFF300, 0x00000000, 0x0020FB00, 0x00000000, 0x00000000,
	0x60800067, 0x00008BB9, 0xFFFFF800u32, 0x00000000, 0xE0003C00u32, 0xFF40F3FAu32, 0x00000000, 0x00000000,
	0x0000FFFF, 0x00CF9A00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
]

let ps2_data_port = 0x60u8
let ps2_control_port = 0x64u8

fun gdtSetEntry(i: UInt8, base: UInt32, limit: UInt64, is64: Bool, typed: GdtType) {
	var gdtd: GdtDescriptor = (gdtTemplate.ref as! UInt64 + i * 2 * 4) as! GdtDescriptor
	gdtd.limitLow = limit & 0xFFFFu16
	gdtd.size = (limit >> 16) & 0xFu8
	// gdtd.size |= (is64 ? 0xa0 : 0xc0)
	gdtd.size |= 0xA0
	gdtd.size <<= 0x0D // Long mode

	gdtd.baseLow = base & 0xFFFFu16
	gdtd.baseMid = (base >> 16) & 0xFFu8
	gdtd.baseHigh = (base >> 24) & 0xFFu8

	gdtd.type =
		(typed | GdtType.System | GdtType.Present)
		as! GdtType
}

// Takes 2 GDT entries
fun tssSetEntry(i: UInt8, base: UInt64, limit: UInt64) {
	var tssd: TssDescriptor = (gdtTemplate.ref as! UInt64 + i * 2 * 4) as! TssDescriptor
	tssd.limitLow = limit & 0xFFFFu16
	tssd.size = (limit >> 16) & 0xFu8

	tssd.base_00 = base & 0xFFFFu16
	tssd.base_16 = (base >> 16) & 0xFFu8
	tssd.base_24 = (base >> 24) & 0xFFu8
	tssd.base_32 = (base >> 32) & 0xFFFFFFFFu32
	tssd.reserved = 0

	tssd.type = (
		GdtType.Accessed |
		GdtType.Execute |
		GdtType.Ring3 | // TODO
		GdtType.Present
	) as! GdtType
}

@aligned(64) var cacheIdtr: Idtr = new Idtr()

fun dumpGDT(desc: GdtDescriptorEx) {
	serialPrintf("[dumpGDT]")

	if desc.accessed != 0 {
		serialPrintf(" accessed")
	}
	if desc.rw != 0 {
		serialPrintf(" rw")
	}
	if desc.direction != 0 {
		serialPrintf(" direction")
	}
	if desc.execute != 0 {
		serialPrintf(" execute")
	}
	if desc.one != 0 {
		serialPrintf(" one")
	}

	if desc.privilege == 0 {
		serialPrintf(" privilege=ring0")
	}
	if desc.privilege == 1 {
		serialPrintf(" privilege=ring1")
	}
	if desc.privilege == 2 {
		serialPrintf(" privilege=ring2")
	}
	if desc.privilege == 3 {
		serialPrintf(" privilege=ring3")
	}

	if desc.present != 0 {
		serialPrintf(" present")
	}
	if desc.zero16one32 != 0 {
		serialPrintf(" zero16one32")
	}
	if desc.blocks != 0 {
		serialPrintf(" pages")
	}

	serialPrintf("\n")
}

fun setupInterruptsAndExceptions() {
	serialPrintln("[cpu] initializing lgdt")

	var sizeof_TssEntry: UInt16 = sizeOf<TssEntry>() as! UInt16
	serialPrintf("[cpu] sizeof_TssEntry 104 = %u == %u\n", sizeof_TssEntry, sizeOf<TssEntry>())

	memset(globalTss as! ArrayPointer<UInt8>, 0, sizeof_TssEntry)
	globalTss.iomap_offset = sizeof_TssEntry
	globalTss.rsp[0] = rsp0stack.ref as! UInt64
	globalTss.rsp[1] = rsp1stack.ref as! UInt64
	globalTss.rsp[2] = rsp2stack.ref as! UInt64
	// TODO zero out stacks
	// TODO more stacks
	globalTss.ist[0] = ist0stack.ref as! UInt64
	globalTss.ist[1] = ist1stack.ref as! UInt64
	globalTss.ist[2] = ist2stack.ref as! UInt64
	globalTss.ist[3] = ist3stack.ref as! UInt64
	globalTss.ist[4] = ist4stack.ref as! UInt64
	globalTss.ist[5] = ist5stack.ref as! UInt64
	globalTss.ist[6] = ist6stack.ref as! UInt64
	globalTss.ist[7] = ist7stack.ref as! UInt64

	serialPrint("[cpu] RSP[0] points to: ")
	serialPrintHex((globalTss.rsp[0] as! UInt64))
	serialPrint("\n")

	serialPrint("[cpu] RSP[1] points to: ")
	serialPrintHex((globalTss.rsp[1] as! UInt64))
	serialPrint("\n")

	serialPrint("[cpu] RSP[2] points to: ")
	serialPrintHex((globalTss.rsp[2] as! UInt64))
	serialPrint("\n")

	var tssBase: UInt64 = globalTss as! UInt64

	// upload
	{
		tssSetEntry(8, tssBase, sizeof_TssEntry)
		// tssSetEntry(8, tssBase, sizeof_TssEntry - 1); TODO
	}

	if false {
		let gdt = gdtTemplate as! ArrayPointer<ByValue<GdtDescriptorEx>>
		for i in 16 {
			if i == 0 {
				continue // Empty
			}
			if i == 8 {
				continue // TSS
			}
			if i == 9 {
				continue // TSS
			}
			if gdt[i].ref.present == 0 {
				continue
			}
			serialPrintf("[dumpGDT] #%u\n", i)
			dumpGDT(gdt[i].ref)
		}
	}

	// globalGdtr.limit = sizeOf(gdtTemplate) - 1
	globalGdtr.limit = (4 * 32) - 1u16
	globalGdtr.base = gdtTemplate.ref as! UInt64
	serialPrint("[cpu] GDTR points to: ")
	serialPrintHex(globalGdtr as! UInt64)
	serialPrint("\n")
	serialPrint("[cpu] GDT points to: ")
	serialPrintHex((globalGdtr.base as! UInt64))
	serialPrint("\n")
	serialPrintf("[cpu] GDT size is %u == %u\n", globalGdtr.limit, 0x7F)
	serialPrintln("[cpu] Calling lgdt")
	lgdt(globalGdtr)
	serialPrintln("[cpu] Calling ltr")
	{
		setTsr(64)
		// TODO setTsr(64 + 3)
	}

	serialPrintln("[cpu] Initializing unknown interrupts")

	// TODO 286 magic number
	for i in 286 {
		initializeCallback(idt[i].ref, unknownInterrupt as! UInt64)
	}

	// CPU exceptions
	initializeCallback(idt[0x00].ref, cpu0x00 as! UInt64)
	initializeCallback(idt[0x01].ref, cpu0x01 as! UInt64)
	initializeCallback(idt[0x02].ref, cpu0x02 as! UInt64)
	initializeCallback(idt[0x03].ref, cpu0x03 as! UInt64)
	initializeCallback(idt[0x04].ref, cpu0x04 as! UInt64)
	initializeCallback(idt[0x05].ref, cpu0x05 as! UInt64)
	initializeCallback(idt[0x06].ref, cpu0x06 as! UInt64)
	initializeCallback(idt[0x07].ref, cpu0x07 as! UInt64)
	initializeCallback(idt[0x08].ref, cpu0x08 as! UInt64)
	initializeCallback(idt[0x09].ref, cpu0x09 as! UInt64)
	initializeCallback(idt[0x0A].ref, cpu0x0A as! UInt64)
	initializeCallback(idt[0x0B].ref, cpu0x0B as! UInt64)
	initializeCallback(idt[0x0C].ref, cpu0x0C as! UInt64)
	initializeCallback(idt[0x0D].ref, cpu0x0D as! UInt64)
	initializeCallback(idt[0x0E].ref, cpu0x0E as! UInt64)
	initializeCallback(idt[0x0F].ref, cpu0x0F as! UInt64)
	initializeCallback(idt[0x10].ref, cpu0x10 as! UInt64)
	initializeCallback(idt[0x11].ref, cpu0x11 as! UInt64)
	initializeCallback(idt[0x12].ref, cpu0x12 as! UInt64)
	initializeCallback(idt[0x13].ref, cpu0x13 as! UInt64)
	initializeCallback(idt[0x14].ref, cpu0x14 as! UInt64)
	initializeCallback(idt[0x15].ref, cpu0x15 as! UInt64)

	// PIC interrupts
	initializeCallback(idt[irq0].ref, timerInterrupt as! UInt64)
	initializeKeyboard(idt[irq1].ref)
	initializeMouse(idt[irq12].ref)

	// Syscalls
	initializeCallback(idt[0x80].ref, syscallInterrupt as! UInt64)
	initializeCallback(idt[0x81].ref, yieldInterrupt as! UInt64)

	cacheIdtr.limit = (sizeOf<IdtEntry>() * idt_size) - 1u16
	cacheIdtr.offset = idt as! UInt64

	serialPrint("[cpu] IDTR points to: ")
	serialPrintHex(cacheIdtr as! UInt64)
	serialPrint("\n")
	serialPrint("[cpu] IDT points to: ")
	serialPrintHex(idt.ref as! UInt64)
	serialPrint("\n")
	serialPrintf("[cpu] IDT size is %u of %u elements of %u==16 size\n", cacheIdtr.limit, idt_size,
				 sizeOf<IdtEntry>())
	serialPrintln("[cpu] loading IDTR")
	// Before you implement the IDT, make sure you have a working GDT
	remapPic()
	serialPrintln("[cpu] calling lidtq")
	loadIdt(cacheIdtr)

	serialPrintln("[cpu] Select segments of value SYS_CODE64_SEL & SYS_DATA32_SEL")
	enterKernelMode()

	// Set PIT frequency
	// Valid values: 57 Hz, 121 Hz, 173 Hz
	// Next valid: `i = 174; while (Math.round(1193181 / i) != (1193181 / i)) {i++;}; console.log(i)`
	writePort(0x43, 0x36)
	let frequency = 1193181 / 121
	writePort(0x40, frequency & 0xFFu8)
	writePort(0x40, (frequency >> 8) & 0xFFu8)

	// Unmasking IRQ to support all the things
	// but NOT keyboard
	writePort(irq1, 0x00 | 0b00000010u8)
	writePort(irq1, 0xFE)
	// 0xFA - timer
	// 0xFC - timer and kb
	// 0xFD - kb
	// 0xFE - timer
	// 0xFF - none
}
