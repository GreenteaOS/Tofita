// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

fun userCallHandled(@volatile process: Pointer<Process>, syscall: TofitaSyscalls): Bool {
	@volatile var frame = Pointer.of(process.frame)

	if syscall == TofitaSyscalls.CreateWindowEx {
		if !probeForReadOkay(frame.rdxArg1, sizeof(CreateWindowExPayload)) {
			return false
		}

		var payload = frame.rdxArg1 as! CreateWindowExPayload

		if probeForReadOkay((payload.lpClassName as! UInt64), 16) {
			serialPrintf("<> lpClassName == %S\n", payload.lpClassName)
		}

		if probeForReadOkay((payload.lpWindowName as! UInt64), 16) {
			serialPrintf("<> lpWindowName == %S\n", payload.lpWindowName)
		}

		var window = dwm.OverlappedWindow_create(process.pid)

		window.hWnd = payload.hWnd

		// TODO proper probe method, probably separate probeForWideCharOkay
		if probeForReadOkay((payload.lpWindowName as! UInt64), 8) {
			window.title = String.duplicate(payload.lpWindowName)
		}

		frame.raxReturn = window.windowId
		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.ShowWindow {
		// TODO merge to probeForReadAndConvert os it takes <T> and returns nullable for `if let`
		if !probeForReadOkay(frame.rdxArg1, sizeof(ShowWindowPayload)) {
			return false
		}

		let payload = frame.rdxArg1 as! ShowWindowPayload

		let windowId: UInt64 = payload.windowId
		let nCmdShow: Int32 = payload.nCmdShow
		var window = dwm.OverlappedWindow_find(process.pid, windowId)

		if window != null {
			window.visible = true
			dwm.OverlappedWindow_attach(windowId)
		}

		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.GetMessage {
		if !probeForReadOkay(frame.rdxArg1, sizeof(GetMessagePayload)) {
			return false
		}

		var payload = frame.rdxArg1 as! GetMessagePayload

		if !probeForWriteOkay((payload.msg as! UInt64), sizeof(Msg)) {
			return false
		}

		frame.raxReturn = process.getMessage(process, payload)

		// Should sorts of loop forever
		if frame.raxReturn {
			process.schedulable = true
		} else {
			// process.syscallToHandle = TofitaSyscalls.GetMessage
			process.awaitsGetMessage = true
		}

		return true
	}

	if syscall == TofitaSyscalls.PostMessage {
		if !probeForReadOkay(frame.rdxArg1, sizeof(PostMessagePayload)) {
			return false
		}

		var payload = frame.rdxArg1 as! PostMessagePayload

		frame.raxReturn = process.postMessage(process, payload)

		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.SwapWindowFramebuffer {
		if !probeForReadOkay(frame.rdxArg1, sizeof(SwapWindowFramebufferPayload)) {
			return false
		}

		let payload = frame.rdxArg1 as! SwapWindowFramebufferPayload

		if !probeForWriteOkay((payload.fb as! UInt64), sizeof(WindowFramebuffer)) {
			return false
		}

		var windowId: UInt64 = payload.windowId

		var fb = payload.fb as! WindowFramebuffer
		var window = dwm.OverlappedWindow_find(process.pid, windowId)

		if window == null {
			return false
		}

		let width = (uint32_t)window.width
		let height = (uint32_t)window.height
		let bytes = width * height * sizeof(Pixel32)

		if window.fbZeta != null {
			window.fbCurrentZeta = !window.fbCurrentZeta
				tmemcpy((Void *)Pointer.of(window.fbZeta.pixels), (const Void *)Pointer.of(window.fbGama.pixels), bytes)
				fb.pixels = (nj.Pixel32 *)Pointer.of(window.fbZeta.pixels)
			if window.fbCurrentZeta {
				fb.width = window.fbZeta.width
				fb.height = window.fbZeta.height
			} else {
				tmemcpy((Void *)Pointer.of(window.fbGama.pixels), (const Void *)Pointer.of(window.fbZeta.pixels), bytes)
				fb.pixels = (nj.Pixel32 *)Pointer.of(window.fbGama.pixels)
				fb.width = window.fbGama.width
				fb.height = window.fbGama.height
			}
		}

		//		if window != null {
		//			var pixelsKernel = window.fbKernel.pixels
		//			var pixelsUser = window.fbUser.pixels
		//			let count = window.fbKernel.width * window.fbKernel.height
		//			for i in count
		//			{
		//				pixelsKernel[i] = pixelsUser[i]
		//			}
		//		}

		// frame.raxReturn = 0
		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.GetOrCreateWindowFramebuffer {
		if !probeForReadOkay(frame.rdxArg1, sizeof(SwapWindowFramebufferPayload)) {
			return false
		}

		let payload = frame.rdxArg1 as! SwapWindowFramebufferPayload

		// TODO probeForWriteOkay alias taking pointer probeForWriteAtOkay
		if !probeForWriteOkay((payload.fb as! UInt64), sizeof(WindowFramebuffer)) {
			return false
		}

		var windowId: UInt64 = payload.windowId

		var fb = payload.fb
		var window = dwm.OverlappedWindow_find(process.pid, windowId)

		if window == null {
			return false
		}

		// TODO resize fb *here* on window size change
		if window.fbZeta == null {
			let width = (uint32_t)window.width
			let height = (uint32_t)window.height

			let bytes = width * height * sizeof(Pixel32)
			// serialPrintln("[GetOrCreateWindowFramebuffer.allocateBytes]")
			// window.fbZeta.pixels = PhysicalAllocator.allocateBytes(bytes) as! Pixel32
			// window.fbGama.pixels = PhysicalAllocator.allocateBytes(bytes) as! Pixel32

			// TODO client width
			window.fbZeta = allocateBitmap(width, height)
			window.fbGama = allocateBitmap(width, height)

			memset((Void *)window.fbZeta.pixels, 0x33, bytes)
			memset((Void *)window.fbGama.pixels, 0x33, bytes)

			// window.fbZeta.width = width // TODO client width
			// window.fbZeta.height = height
			// window.fbGama.width = width // TODO client width
			// window.fbGama.height = height
		}

			fb.pixels = (nj.Pixel32 *)Pointer.of(window.fbZeta.pixels)
		if window.fbCurrentZeta {
			fb.width = window.fbZeta.width
			fb.height = window.fbZeta.height
		} else {
			fb.pixels = (nj.Pixel32 *)Pointer.of(window.fbGama.pixels)
			fb.width = window.fbGama.width
			fb.height = window.fbGama.height
		}

		// frame.raxReturn = 0
		process.schedulable = true
		return true
	}

	return false
}
