// The Tofita Kernel
// Copyright (C) 2021  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

import "../boot/shared/boot.hpp"

#define unsigned do_not_use_such_types_please
#define long do_not_use_such_types_please

import "tofita.hpp"

// Generated by Hexa compiler
#define HEXA_NO_DEFAULT_INCLUDES


fun serialPrintf(const c: Pointer<WideChar>, ...)
Void printf(const char *c, ...) {
	serialPrintf("<Hexa> printf %s\n", c)
}
Void fflush(pipe: Pointer<Void>) {
	serialPrintf("<Hexa> fflush\n")
}
Void *malloc(bytes: UInt64) {
	serialPrintf("<Hexa> malloc\n")
	return (Void *)allocateBytes(bytes)
}
// Void memcpy(...){}
fun memcpy(dest: VoidPointer, src: ConstVoidPointer, n: UInt64)
Int32 wcslen(string_: ConstWideCharPointer) {
	serialPrintf("<Hexa> wcslen\n")
	var i: Int32 = 0
	while (string_[i] != '\0')
		i++
	return i
}
Void free(ptr: Pointer<Void>) {
	serialPrintf("<Hexa> free\n")
}
declare FILE = Void
#define HEXA_MAIN mainHexa
#define HEXA_NEW(z) malloc(z)
import "hexa.cpp"
#define char do_not_use_such_types_please
#define int do_not_use_such_types_please

Void *memset(dest: VoidPointer, e: Int32, len: UInt64) {
	var d: Pointer<UInt8> = (UInt8 *)dest
	for (UInt64 i = 0; i < len; i++, d++) {
		*d = e
	}
	return dest
}

fun memzero(dest: VoidPointer, len: UInt64) {
	memset(dest, 0, len)
}

fun ___chkstk_ms(): Void {}

import "util/Math.cpp"
import "util/String.cpp"

import "../devices/cpu/cpu.hpp"
import "../devices/cpu/amd64.cpp"
import "../devices/serial/log.cpp"
import "../devices/cpu/cpuid.cpp"
import "../devices/cpu/spinlock.cpp"
import "../devices/cpu/exceptions.cpp"
import "../devices/cpu/interrupts.cpp"
import "../devices/cpu/seh.cpp"
import "../devices/cpu/rdtsc.cpp"
import "../devices/efi/efi.cpp"
import "../devices/cpu/physical.cpp"
import "../devices/cpu/pages.cpp"
import "../devices/screen/framebuffer.cpp"
import "../devices/ps2/keyboard.cpp"
import "../devices/ps2/mouse.cpp"
import "../devices/ps2/polling.cpp"
import "../devices/cpu/fallback.cpp"
import "../devices/acpi/acpi.cpp"
import "formats/exe/exe.hpp"
import "ramdisk.cpp"
import "module.cpp"
import "sandbox.cpp"
import "user.cpp"
import "process.cpp"
// STB library
#define STBI_NO_SIMD
#define STBI_NO_STDIO
#define STB_IMAGE_IMPLEMENTATION
#define STBI_ONLY_PNG
import "formats/stb_image/libc.cpp"
import "formats/stb_image/stb_image.hpp"
import "formats/stb_image/unlibc.cpp"
import "formats/exe/exe.cpp"
import "formats/cur/cur.cpp"
import "formats/ico/ico.cpp"
import "formats/bmp/bmp.cpp"
import "formats/lnk/lnk.cpp"
import "gui/blur.cpp"
import "gui/desktop.cpp"
import "gui/quake.cpp"
import "gui/text.cpp"
import "gui/windows.cpp"
import "gui/compositor.cpp"
import "gui/dwm.cpp"
import "syscalls/user32/userCall.cpp"

const KernelParams *paramsCache = null
var startupMilliseconds: UInt64 = 0

fun kernelInit(const params: Pointer<KernelParams>) {
	serialPrintln("<Tofita> GreenteaOS " versionName " " STR(versionMajor) "." STR(
		versionMinor) " " versionTag " kernel loaded and operational")
	serialPrintf("<Tofita> CR3 points to: %8\n", (params.pml4 as! UInt64))
	paramsCache = params
	// PhysicalAllocator.init(Pointer.of(params.efiMemoryMap), params.physicalRamBitMaskVirtual,
	// DOWN_BYTES_TO_PAGES(params.ramBytes))
	PhysicalAllocator.init(params)
	pages.pml4entries = (pages.PageEntry *)((wholePhysicalStart as! UInt64) + (uint64_t)(params.pml4))

	if (false) {
		pages.mapMemory(pages.pml4entries, 4096, 4096, 256)
		pages.mapMemory(pages.pml4entries, 4096, 4096, 256)
		pages.mapMemory(pages.pml4entries, 4096 * 20, 4096 * 10, 256)

		serialPrintf("<> %8 == %8\n", (uint64_t)(4096 * 10),
					 pages.resolveAddr(pages.pml4entries, 4096 * 20))
		serialPrintf("<> %8 == %8\n", (uint64_t)(4096 * 10 + 123),
					 pages.resolveAddr(pages.pml4entries, 4096 * 20 + 123))
		serialPrintf("<> %8 == %8\n", (uint64_t)(0),
					 pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64)))
		serialPrintf("<> %8 == %8\n", (uint64_t)(0 + 123),
					 pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64) + 123))
		serialPrintf("<> %8 == %8\n", (uint64_t)(0 + 4096),
					 pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64) + 4096))
		serialPrintf(
			"<> %8 == %8\n", (uint64_t)(0 + 4096 * 1000 + 123),
			pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64) + 4096 * 1000 + 123))
		serialPrintf("<> %8 == %8\n", (uint64_t)(1048576),
					 pages.resolveAddr(pages.pml4entries, (uint64_t)0xffff800000000000))
		serialPrintf("<> %8 == %8\n", (uint64_t)(1048576 + 123),
					 pages.resolveAddr(pages.pml4entries, (uint64_t)0xffff800000000000 + 123))

		// serialPrint("resolves from, to, wh, wh+8888: ")
		// serialPrint("\n")
		// serialPrintHex(4096 * 10)
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr(4096 * 20 + 123))
		// serialPrint("==\n")
		// serialPrintHex(pages.resolveAddr(4096 * 20))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((wholePhysicalStart as! UInt64)))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((wholePhysicalStart as! UInt64) + 8888))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((wholePhysicalStart as! UInt64) + 4096 * 1000))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((uint64_t)0xffff800000000000))
		// serialPrint("\n")
	}

	setFramebuffer(Pointer.of(params.framebuffer))
	setRamDisk(Pointer.of(params.ramdisk))

	if (sizeof(UInt8 *) == 4)
		serialPrintln("<Tofita> void*: 4 bytes")
	if (sizeof(UInt8 *) == 8)
		serialPrintln("<Tofita> void*: 8 bytes")

#ifdef __cplusplus
	serialPrintln("<Tofita> __cplusplus")
#else
	serialPrintln("<Tofita> !__cplusplus")
#end

#if defined(__clang__)
	serialPrintln("<Tofita> __clang__")
#elif defined(__GNUC__) || defined(__GNUG__)
	serialPrintln("<Tofita> __GNUC__")
#elif defined(_MSC_VER)
	serialPrintln("<Tofita> _MSC_VER")
#end

	disablePic()
	enableInterrupts()
	enablePS2Mouse()

	initText()
	initializeCompositor()

	quakePrintf("GreenteaOS " versionName
				" " STR(versionMajor) "." STR(versionMinor) " " versionTag " loaded and operational\n")

	// enableLocalApic()

	var cpuid: CPUID = getCPUID()

	var megs: UInt32 = Math.round((double)params.ramBytes / (1024.0 * 1024.0))
	quakePrintf("[CPU] %s %s %d MB RAM\n", cpuid.vendorID, cpuid.brandName, megs)

	if (!ACPIParser.parse(params.acpiTablePhysical)) {
		quakePrintf("ACPI is *not* loaded\n")
	} else {
		quakePrintf("ACPI 2.0 is loaded and ready\n")
	}

	quakePrintf("Enter 'help' for commands\n")

	{
		// TODO move to compositor
		var a: RamDiskAsset = getRamDiskAsset("root/Windows/Web/Wallpaper/Tofita/default.bmp")
		var bmp: Pointer<Bitmap32> = bmp.loadBmp24(&a)
		setWallpaper(bmp, Center)
	}

	// var sandbox = sandbox.createSandbox()
	dwm.initDwm()

	// Setup scheduling
	currentThread = THREAD_INIT

	// GUI thread
	{
		memset(Pointer.of(guiThreadFrame), 0, sizeof(InterruptFrame)) // Zeroing
		memset(Pointer.of(guiStack), 0, sizeof(stackSizeForKernelThread)) // Zeroing

		guiThreadFrame.ip = (uint64_t)Pointer.of(guiThreadStart)
		guiThreadFrame.cs = SYS_CODE64_SEL
		// TODO allocate as physicall memory
		guiThreadFrame.sp = (uint64_t)Pointer.of(guiStack) + stackSizeForKernelThread
		guiThreadFrame.ss = SYS_DATA32_SEL
	}

	// Main thread
	{
		memset(Pointer.of(kernelThreadFrame), 0, sizeof(InterruptFrame)) // Zeroing
		memset(Pointer.of(kernelStack), 0, sizeof(stackSizeForKernelThread)) // Zeroing

		kernelThreadFrame.ip = (uint64_t)Pointer.of(kernelThreadStart)
		kernelThreadFrame.cs = SYS_CODE64_SEL
		kernelThreadFrame.sp = (uint64_t)Pointer.of(kernelStack) + stackSizeForKernelThread
		kernelThreadFrame.ss = SYS_DATA32_SEL
	}

	// Idle process
	{
		memset(Pointer.of(process.processes), 0, sizeof(process.processes)) // Zeroing
		var idle: Pointer<process.Process> = Pointer.of(process.processes[0])
		idle.pml4 = pages.pml4entries // Save CR3 template to idle process
		idle.schedulable = true // At idle schedule to idle process
		idle.present = true
		idle.syscallToHandle = TofitaSyscalls.Noop
		process.currentProcess = 0
		pml4kernelThread = process.processes[0].pml4
	}

	// Demo
	if (false) {
		for (UInt8 i = 0; i < 3; ++i) {
			var demo: Pointer<process.Process> = process.Process_create()
			serialPrintf("<> pid == %u\n", demo.pid)
			process.Process_init(demo)
			exe.loadExeIntoProcess("desktop/wndapp.exe", demo)
			demo.schedulable = true
		}
	}

	startupMilliseconds = paramsCache.time.Hour * 60 * 60 * 1000 + paramsCache.time.Minute * 60 * 1000 +
						  paramsCache.time.Second * 1000

	// Show something before scheduling delay
	composite(startupMilliseconds)
	copyToScreen()
	serialPrintln("<Tofita> [ready for scheduling]")
}

fun switchToUserProcess() {
	// if (processesCount == 0)
	//	amd64.enableAllInterruptsAndHalt()
	// TODO
	var next = getNextProcess()

	if (next == 0) {
		markAllProcessessSchedulable()
		next = getNextProcess()
	}

	if (next == 0) {
		// serialPrintln("<Tofita> [halt]")
		// amd64.enableAllInterruptsAndHalt() // Nothing to do
	}
	// else
	amd64.yield()
	// TODO
}

fun kernelThread() {
	serialPrintln("<Tofita> [kernelThread] thread started")

	// TODO move to preTest with infinite loop on fail
	serialPrintf("<seh> 0 == %u\n", probeForReadOkay((uint64_t)321, 1))
	serialPrintf("<seh> 1 == %u\n", probeForReadOkay((uint64_t)Pointer.of(currentThread), 1))
	serialPrintf("<seh> 0 == %u\n", probeForReadOkay((uint64_t)999999999, 1))
	serialPrintf("<seh> 1 == %u\n", probeForReadOkay((uint64_t)Pointer.of(guiStack), 1))
	serialPrintf("<seh> 0 == %u\n", probeForReadOkay((uint64_t)-1, 1))
	serialPrintf("<seh> 1 == %u\n", probeForReadOkay((uint64_t)Pointer.of(switchToNextProcess), 1))

	while (true) {
		@volatile index: UInt64 = 1 // Idle process ignored
		while (index < 255) {		 // TODO
			@volatile process.Process *process = Pointer.of(process.processes[index])
			if (process.present == true) {
				if (process.syscallToHandle != TofitaSyscalls.Noop) {
					@volatile let syscall = process.syscallToHandle
					process.syscallToHandle = TofitaSyscalls.Noop
					@volatile var frame = Pointer.of(process.frame)

					// Select pml4 to work within current process memory
					// Remember pml4 for proper restore from scheduling
					pml4kernelThread = process.pml4
					amd64.writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))

					// TODO refactor to separate syscall handler per-DLL

					if (syscall == TofitaSyscalls.DebugLog) {
						serialPrintf("[[DebugLog:PID %d]] ", index)
						serialPrintf("[[rcx=%u rdx=%u r8=%u]] ", frame.rcxArg0, frame.rdxArg1, frame.r8)

						if (probeForReadOkay(frame.rdxArg1, sizeof(DebugLogPayload))) {
							var payload: Pointer<DebugLogPayload> = (DebugLogPayload *)frame.rdxArg1
							// Note this is still very unsafe
							if (probeForReadOkay((payload.message as! UInt64), 1)) {
								serialPrintf(payload.message, payload.extra, payload.more)
							}
						}

						serialPrintf("\n")
						process.schedulable = true
					} else if (syscall == TofitaSyscalls.ExitProcess) {
						serialPrintf("[[ExitProcess:PID %d]] %d\n", index, frame.rdxArg1)
						process.present = false

						// Select pml4 of idle process for safety
						pml4kernelThread = process.processes[0].pml4
						amd64.writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))

						// Deallocate process
						process.Process_destroy(process)
					} else if (syscall == TofitaSyscalls.Cpu) {
						serialPrintf("[[Cpu:PID %d]] %d\n", index, frame.rdxArg1)
						quakePrintf("Process #%d closed due to CPU exception #%u\n", index, frame.index)
						process.present = false

						// Page fault
						if (frame.index == 0x0E)
							quakePrintf("#PF at %8\n", process.cr2PageFaultAddress)
						if (frame.index == 0x0D)
							quakePrintf("#GPF at %8\n", frame.ip)
						if (frame.index == 0x03)
							quakePrintf("#BP at %8\n", frame.ip)

						// Select pml4 of idle process for safety
						pml4kernelThread = process.processes[0].pml4
						amd64.writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))

						// Deallocate process
						process.Process_destroy(process)
					} else {
						frame.raxReturn = 0 // Must return at least something
						// Note ^ some code in syscall handlers may *read* this value
						// So set it to zero just in case

						if (!userCall.userCallHandled(process, syscall)) {
							// Unknown syscall is no-op
							serialPrintf("[[PID %d]] Unknown or unhandled syscall %d\n", index,
										 frame.rcxArg0)
							frame.raxReturn = 0
							process.schedulable = true
						}
					}
				}
			}
			index++
		}

		switchToUserProcess()
	}
}

fun guiThreadStart()

fun kernelThreadStart()

// In case of kernel crash set instruction pointer to here
fun kernelThreadLoop() {
	serialPrintln("<Tofita> [looping forever]")
	while (true) {
		amd64.pause()
	}
}

fun guiThread() {
	serialPrintln("<Tofita> [guiThread] thread started")

	while (true) {
		// Poll PS/2 devices
		pollPS2Devices()

		if (haveToRender == false) {
			switchToUserProcess()
		}

		haveToRender = false

		composite(startupMilliseconds)
		copyToScreen()

		switchToUserProcess()
	}
}

fun kernelMain(const params: Pointer<KernelParams>) {
	kernelInit(params)
	mainHexa(0, null)
	__sync_synchronize()

	// TODO composite here first frame!!!
	// cause if crashes on hardware, at least it shows something

	// sti . start sheduling here
	// It will erase whole stack on next sheduling
	// TOOD kernel `yield`/`await`
	while (true) {
		amd64.enableAllInterruptsAndHalt()
	}
	// TODO hexa: error if code present in unreachable block
	// (no break/continue/throw)
}
}
