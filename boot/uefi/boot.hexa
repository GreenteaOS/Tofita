// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Boot loader: enters efi_main, reads all UEFI data and starts kernel loader

fun compareGuid(efi.guid1: Pointer<EFI_GUID>, efi.guid2: Pointer<EFI_GUID>): efi.INTN {
	let g1: Pointer<efi.INT32> = guid1 as! Pointer<efi.INT32>
	let g2: Pointer<efi.INT32> = guid2 as! Pointer<efi.INT32>
	var r: efi.INT32 = g1[0] - g2[0]
	r |= g1[1] - g2[1]
	r |= g1[2] - g2[2]
	r |= g1[3] - g2[3]
	return r
}

fun tmemcpy(dest: VoidPointer, src: ConstVoidPointer, count: UInt64): VoidPointer {
	var dst8 = dest as! Pointer<UInt8>
	var src8 = src as! Pointer<UInt8>

	while (count--) {
		*dst8++ = *src8++
	}

	return dest
}

// Loading animation, progress 0...2
fun drawLoading(framebuffer: Framebuffer, progress: UInt8) {
	for y in leavesHeight {
		for x in leavesWidth {
			let pixel = getBitmapPixel(binLeavesBitmap, x, y, leavesWidth, leavesHeight)
			drawPixel(framebuffer,
					  x + framebuffer.width / 2 - (leavesWidth / 2) + progress * leavesWidth * 2 -
						  leavesWidth * 2,
					  y + (framebuffer.height / 4) * 3, pixel)
		}
	}
}

fun memset(dest: VoidPointer, e: Int32, len: UInt64): VoidPointer {
	var d = dest as! Pointer<UInt8>
	for (UInt64 i = 0; i < len; i++, d++) {
		*d = e
	}
	return dest
}

// CR3 trampoline
@extern @rename("trampolineCR3") @fastcall fun
trampolineCR3(@volatile kernelParams: UInt64, @volatile pml4: UInt64, @volatile stack: UInt64,
			  @volatile entry: UInt64): Void

@extern @rename('versionMajor') declare let versionMajor: Int
@extern @rename('versionMinor') declare let versionMinor: Int
@extern @rename('versionTag') declare let versionTag: Int
// TODO ^ to C++n't about -D
// @deep

// Entry point
fun efi_main(imageHandle: ByValue<EFI_HANDLE>, systemTable: EFI_SYSTEM_TABLE): EFI_STATUS {
	initSerial()

	serialPrint("\n[[[efi_main]]] Tofita " + versionMajor + "." +
		versionMinor + "." + versionTag + " UEFI bootloader. Welcome!\n")

	initText()

	// Disable watchdog timer
	systemTable.bootServices.setWatchdogTimer(0, 0, 0, null)

	{
		var revision: UInt32 = systemTable.firmwareRevision
		var minor: UInt16 = revision as! UInt16
		var major: UInt16 = (revision >> 16) as! UInt16
		serialPrintf("[[[efi_main]]] UEFI revision %d.%d\n", major, minor)
	}

	// Actually, no matter where lower is present, cause no lower-relative addressing done in kernel
	// after calling cr3 at the first instruction
	// so it is safe to allocate it at random position in conventional memory

	let upper: UInt64 = 0xffff800000000000 as! UInt64
	var acpiTable: Pointer<Void> = null
	{
		serialPrintln("[[[efi_main]]] begin: ACPI")
		var acpi20: efi.EFI_GUID = ACPI_20_TABLE_GUID
		var acpi: efi.EFI_GUID = ACPI_TABLE_GUID

			var efiTable: Pointer<efi.EFI_CONFIGURATION_TABLE> = Pointer.of(systemTable.ConfigurationTable[i])
			if (0 == compareGuid(Pointer.of(efiTable.VendorGuid), Pointer.of(acpi20))) { // Prefer ACPI 2.0
		for i in systemTable.numberOfTableEntries {
				acpiTable = efiTable.vendorTable
				serialPrintln("[[[efi_main]]] found: ACPI 2.0")
				break
			} else if (0 == compareGuid(Pointer.of(efiTable.VendorGuid), Pointer.of(acpi))) {
				// acpiTable = (Void *)((intptr_t)efiTable.VendorTable | 0x1) // LSB high
				// ACPI 2.0 is required by Tofita
				// So we don't need to support ACPI 1.0
				serialPrintln("[[[efi_main]]] found: ACPI 1.0, ignoring")
			}
		}

		// TODO also transfer ACPI version to report SandyBridge
		serialPrintln("[[[efi_main]]] done: ACPI")
	}

	var status = EFI_STATUS.EFI_NOT_READY

	serialPrintln("[[[efi_main]]] begin: initializeFramebuffer")
	var framebuffer: Framebuffer = new Framebuffer()
	initializeFramebuffer(framebuffer, systemTable)
	drawLoading(framebuffer, 0)
	let versionText = "Greentea OS " + versionMajor + "." + versionMinor + "." + versionTag
	drawText(
		versionText,
		(framebuffer.height / 4) * 3 + 64 as! Int16,
		framebuffer
	)
	let errorY: Int16 = (framebuffer.height / 4) * 3 + 64 + 32 as! Int16

	// Check ACPI here, after framebuffer initialization
	while acpiTable == null {
		drawText("[ERROR] Tofita requires ACPI 2.0 [ERROR]", errorY, framebuffer)
	}

	// TODO: render something to show that loader is ok, because initial start form USB may take a while
	// TODO: show error message if ram < 512 or < 1024 mb and cancel boot (loop forever)
	serialPrintln("[[[efi_main]]] done: initializeFramebuffer")
	// TODO: log all ^ these to framebuffer (optionally)

	// Initial RAM disk
	var ramdisk: RamDisk = new RamDisk()
	status = findAndLoadRamDisk(systemTable.bootServices, ramdisk)
	while status != EFI_STATUS.EFI_SUCCESS {
		drawText("[ERROR] Tofita cannot load ramdisk [ERROR]", errorY, framebuffer)
	}
	drawLoading(framebuffer, 1)

	serialPrintln("[[[efi_main]]] begin: fillMemoryMap")
	var sizeAlloc: UInt64 = (ramdisk.size / pageSize + 1) * pageSize
	var efiMemoryMap: EfiMemoryMap = new EfiMemoryMap()
	efiMemoryMap.memoryMapSize = sizeOf<EFI_MEMORY_DESCRIPTOR>() * 512u64
	// TODO bug efiMemoryMap.memoryMapSize = sizeOf<EFI_MEMORY_DESCRIPTOR>() * 512
	// TODO sizeOf<EFI_MEMORY_DESCRIPTOR>() ?
	efiMemoryMap.memoryMap = (ramdisk.base + sizeAlloc) as! EFI_MEMORY_DESCRIPTOR
	{
		var b = efiMemoryMap.memoryMap as! ArrayPointer<UInt8>
		for i in efiMemoryMap.memoryMapSize {
			// TODO faster with uint64_t
			b[i] = buffa[0]
		}
	}
	fillMemoryMap(efiMemoryMap, systemTable)
	serialPrintln("[[[efi_main]]] done: fillMemoryMap")

	var time: EFI_TIME
	time.year = 2022
	var capabilities: EFI_TIME_CAPABILITIES
	{
		serialPrintln("[[[efi_main]]] begin: GetTime")
		var status: efi.EFI_STATUS = systemTable.RuntimeServices.GetTime(Pointer.of(time), Pointer.of(capabilities))
		while status != EFI_STATUS.EFI_SUCCESS {
			serialPrintln("[[[efi_main]]] <ERROR> GetTime")
			drawText("[ERROR] Cannot get current time from UEFI [ERROR]", errorY, framebuffer)
		}

		{
			serialPrintf("[[[efi_main]]] EFI_TIME Year=%d Month=%d Day=%d Hour=%d Minute=%d Second=%d "
						 +
						 "Nanosecond=%d TimeZone=%d Daylight=%d\n",
						 time.year, time.month, time.day, time.hour, time.minute, time.second,
						 time.nanosecond, time.timeZone, time.daylight)

			serialPrintf("[[[efi_main]]] EFI_TIME_CAPABILITIES Resolution=%d Accuracy=%d SetsToZero=%d\n",
						 capabilities.resolution,
						 capabilities.accuracy,
						 capabilities.setsToZero)

			// Set 2022 as least valid, so security/HTTPS certificates at least partially work
			// and file system is not messed
			if time.year < 2022 {
				time.year = 2022
			}
		}
		serialPrintln("[[[efi_main]]] done: GetTime")
	}

	serialPrintln("[[[efi_main]]] begin: ExitBootServices")
	var oops: UInt8 = 0
	status = EFI_STATUS.EFI_NOT_READY
	while status != EFI_STATUS.EFI_SUCCESS {
		if oops < 10 {
			serialPrintln("[[[efi_main]]] try: ExitBootServices")
		}

		if oops == 100 {
			drawText("Loading...", errorY, framebuffer)
			serialPrintln("[[[efi_main]]] <ERROR?> probably infinite loop on ExitBootServices")
			serialPrintln("[[[efi_main]]] <ERROR?> system may or may not start")
			oops = 200
		}

		if oops < 100 {
			oops++
		}

		status = systemTable.bootServices.exitBootServices(imageHandle, efiMemoryMap.mapKey)
	}

	if status != EFI_STATUS.EFI_SUCCESS {
		// TODO `status` to string
		serialPrintln("[[[efi_main]]] <ERROR> ExitBootServices: EFI_LOAD_ERROR")
		return EFI_STATUS.EFI_LOAD_ERROR
	}
	serialPrintln("[[[efi_main]]] done: ExitBootServices")

	setRamDisk(ramdisk)

	serialPrintln("[[[efi_main]]] begin: preparing kernel loader")

	// TODO forward constructor arguments `var asset: ByValue<RamDiskAsset> = new ByValue<RamDiskAsset>()`
	var asset: RamDiskAsset = new RamDiskAsset()
	getRamDiskAsset(asset, "tofita.gnu")
	serialPrintf("[[[efi_main]]] loaded asset 'tofita.gnu' %d bytes at %d\n", asset.size, asset.data)

	let largeBuffer: UInt64 = conventionalAllocateLargest(efiMemoryMap)
	serialPrintf("[[[efi_main]]] large buffer allocated at %u\n", largeBuffer)
	conventionalOffset = largeBuffer
	var mAddressOfEntryPoint: UInt64 = 0

	{
		var ptr = (UInt8 *)asset.data
		var peHeader = (const PeHeader *)((ptr as! UInt64) + ptr[0x3C] + ptr[0x3C + 1] * 256)
		serialPrintf("PE header signature 'PE' == '%s'\n", peHeader)
		var peOptionalHeader = (const Pe32OptionalHeader *)((peHeader as! UInt64) + sizeof(PeHeader))
		serialPrintf("PE32(+) optional header signature 0x020B == %d == %d\n", peOptionalHeader.mMagic,
					 0x020B)
		serialPrintf("PE32(+) size of image == %d\n", peOptionalHeader.mSizeOfImage)
		memset(kernelBase, 0, peOptionalHeader.mSizeOfImage) // Zeroing
		var kernelBase = conventionalAllocateNext(peOptionalHeader.mSizeOfImage)

		// Copy sections
		var imageSectionHeader =
			(const ImageSectionHeader *)((peOptionalHeader as! UInt64) + peHeader.mSizeOfOptionalHeader)
			serialPrintf("Copy section [%d] named '%s' of size %d\n", i, Pointer.of(imageSectionHeader[i].mName),

		for i in peHeader.mNumberOfSections {
						 imageSectionHeader[i].mSizeOfRawData)
			var where: UInt64 = (kernelBase as! UInt64) + imageSectionHeader[i].mVirtualAddress

			tmemcpy((Void *)where,
					(Void *)((asset.data as! UInt64) + (imageSectionHeader[i].mPointerToRawData as! UInt64)),
					imageSectionHeader[i].mSizeOfRawData)
		}

		mAddressOfEntryPoint = peOptionalHeader.mAddressOfEntryPoint
	}

	var params = conventionalAllocateNext(sizeOf<KernelParams>()) as! KernelParams
	{
		var b = params as! ArrayPointer<UInt8>
		for i in sizeOf<KernelParams>() {
			b[i] = buffa[0]
		}
	}

	params.time = time
	params.capabilities = capabilities

	// Note: stack grows from x to X-N, not X+N
	// TODO: map empty page for stack overflow protection + map larger stack (~4 MB)
	var stack = conventionalAllocateNext(1024u64 * 1024) + 1024 * 1024
	{
		var b = (stack - 1024 * 1024) as! ArrayPointer<UInt8>
		for i in 1024 * 1024 {
			b[i] = buffa[0]
		}
	}

	params.ramdisk = ramdisk
	params.framebuffer = framebuffer
	params.efiMemoryMap.ref.memoryMap = efiMemoryMap.memoryMap
	params.efiMemoryMap.ref.memoryMapSize = efiMemoryMap.memoryMapSize
	params.efiMemoryMap.ref.mapKey = efiMemoryMap.mapKey
	params.efiMemoryMap.ref.descriptorSize = efiMemoryMap.descriptorSize
	params.efiMemoryMap.ref.descriptorVersion = efiMemoryMap.descriptorVersion

	// RAM usage bit-map

	var ram: UInt64 = getRAMSize(params.efiMemoryMap.ref)
	var megs: UInt32 = (ram / (1024u64 * 1024u64)) as! UInt32
	serialPrintf("[paging] available RAM is ~%u bytes\n", ram)
	serialPrintf("[paging] available RAM is ~%u megabytes\n", megs)

	while megs < 1234 {
		drawText("[ERROR] Tofita requires at least 2 GB of memory [ERROR]", errorY, framebuffer)
		serialPrintf("Tofita requires at least 2 GB of memory\n")
	}

	params.ramBytes = ram
	params.physicalRamBitMaskVirtual = conventionalAllocateNext(ram >> 12)

	pml4entries =
		conventionalAllocateNext(sizeOf<PageEntry>() * pageTableSize) as! ArrayPointer<ByValue<PageEntry>>

	{
		for i in conventionalOffset {
		var b = pml4entries as! ArrayPointer<UInt8>
			// TODO faster with uint64_t
			b[i] = buffa[0]
		}
	}

	// Map memory

	serialPrintln("[[[efi_main]]] mapping pages for kernel loader")

	mapMemory(upper, largeBuffer, (conventionalOffset - largeBuffer) / pageSize + 1, 1)

	// Note: framebuffer is *not* within physical memory
	mapFramebuffer(params.framebuffer.ref)
	drawLoading(framebuffer, 2)
	mapEfi(params.efiMemoryMap.ref)
	mapMemoryHuge(wholePhysicalStart, 0, ram / pageSize)

	let startFunction = (conventionalOffset + pageSize) as! InitKernelTrampoline
	tmemcpy(startFunction as! ArrayPointer<UInt8>, trampolineCR3 as! ConstArrayPointer<UInt8>, 32)
	mapMemory((startFunction as! UInt64), (startFunction as! UInt64), 1, 0)

	// Fix virtual addresses

	params.framebuffer.physical = params.framebuffer.base
	params.framebuffer.base = framebufferStart

	params.ramdisk.physical = params.ramdisk.base
	params.ramdisk.base = wholePhysicalStart + params.ramdisk.physical

	params.pml4 = (pml4entries as! UInt64) // physical address for CPU
	params.stack = stack // physical address for stack overflow detection
	params.physicalBuffer = largeBuffer
	params.physicalBytes = conventionalOffset - largeBuffer
	params.efiRuntimeServices = systemTable.runtimeServices
	params.acpiTablePhysical = acpiTable as! UInt64
	params.efiMemoryMap.ref.memoryMap =
		(wholePhysicalStart + (params.efiMemoryMap.ref.memoryMap as! UInt64)) as! EFI_MEMORY_DESCRIPTOR

	// Convert addresses to upper half

	stack = (wholePhysicalStart as! UInt64) + stack
	params.physicalRamBitMaskVirtual = (wholePhysicalStart as! UInt64) + params.physicalRamBitMaskVirtual
	params = (KernelParams *)((wholePhysicalStart as! UInt64) + (params as! UInt64))

	serialPrintln("[[[efi_main]]] done: all done, entering kernel loader")

	serialPrint("[[[efi_main]]] CR3 points to: ")
	serialPrintHex((pml4entries as! UInt64))
	serialPrint("\n")

	startFunction((params as! UInt64), (pml4entries as! UInt64), stack, upper + mAddressOfEntryPoint)

	return EFI_STATUS.EFI_SUCCESS
}
