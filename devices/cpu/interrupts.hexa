// The Tofita Kernel
// Copyright (C) 2020  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

let PIC1 = 0x20 // IO base address for main PIC
let PIC2 = 0xA0 // IO base address for secondary PIC
let PIC1_COMMAND PIC1
let PIC1_COMMAND_0x20 = 0x20
let PIC1_DATA (PIC1 + 1)
let PIC2_COMMAND PIC2
let PIC2_DATA (PIC2 + 1)
let PIC_EOI = 0x20	  // End-of-interrupt command code
let PIC_EOI_0x20 = 0x20 // End-of-interrupt command code

UInt8 readPort(port: UInt16)
fun writePort(@volatile UInt16 port, @volatile UInt8 value)
UInt8 mouseRead()

Void tmemcpy(dest: VoidPointer, src: ConstVoidPointer, count: UInt64) {
	var dst8: Pointer<UInt8> = (UInt8 *)dest
	var src8: Pointer<UInt8> = (UInt8 *)src

	while (count--) {
		*dst8++ = *src8++
	}
}

Void tmemcpy(@volatile dest: VoidPointer, const @volatile src: VoidPointer, @volatile count: UInt64) {
	var dst8: Pointer<UInt8> = (UInt8 *)dest
	var src8: Pointer<UInt8> = (UInt8 *)src

	while (count--) {
		*dst8++ = *src8++
	}
}

@struct @packed @sizeOf(10)
class Idtr {
	var limit: UInt16
	var offset: UInt64
}

@struct @packed
class IdtEntry {
	UInt16 offsetLowerbits : 16
	UInt16 selector : 16
	UInt8 ist : 8
	UInt8 gateType : 4
	UInt8 z : 1
	UInt8 dpl : 2
	UInt8 present : 1
	UInt64 offsetHigherbits : 48
	UInt32 zero : 32
}

UInt8 readPort(@volatile UInt16 port) {
	return portInb(port)
}

fun writePort(@volatile UInt16 port, @volatile UInt8 value) {
	portOutb(port, value)
}

fun loadIdt(@volatile idtr: Pointer<Idtr>)

// Handling IDT
let IDT_SIZE = 256
// Records of the GDT - 16 items
let NULL_SEL = 0x00
//let EMPTY_SEL = 0x08
let SYS_CODE64_SEL = 0x10 // Execute/Read
let SYS_DATA32_SEL = 0x18 // Read/Write
// Layout expected by SYSRET
let USER_CODE32_SEL = 0x20 // Execute/Read
let USER_DATA32_SEL = 0x28 // Read/Write
let USER_CODE64_SEL = 0x30 // Execute/Read
//let EMPTY_SEL = 0x38
//let TSS_SEL = 0x40 // Index = 8
//let TSS_SEL = 0x48
//let USER_DATA32_SEL = 0x50 // Read/Write
//let EMPTY_SEL = 0x58
let SYS_CODE32_SEL = 0x60 // Execute/Read
//let EMPTY_SEL = 0x68
//let EMPTY_SEL = 0x70
//let EMPTY_SEL = 0x78

IdtEntry IDT[IDT_SIZE]

// Handling keyboard
@extern fun keyboardHandler()
fun initializeKeyboard(entry: Pointer<IdtEntry>) {
	var keyboardAddress: UInt64 = ((keyboardHandler as! UInt64))
	entry.offsetLowerbits = keyboardAddress & 0xffff
	entry.offsetHigherbits = (keyboardAddress & 0xffffffffffff0000) >> 16
	entry.selector = SYS_CODE64_SEL
	entry.zero = 0
	entry.ist = 2 // Stack
	entry.z = 0
	entry.dpl = 0 // Ring 0
	entry.present = 1
	entry.gateType = 0xe // Interrupt gate
}

@extern fun mouseHandler()
fun initializeMouse(entry: Pointer<IdtEntry>) {
	var mouseAddress: UInt64 = ((mouseHandler as! UInt64))
	entry.offsetLowerbits = mouseAddress & 0xffff
	entry.offsetHigherbits = (mouseAddress & 0xffffffffffff0000) >> 16
	entry.selector = SYS_CODE64_SEL
	entry.zero = 0
	entry.ist = 2 // Stack
	entry.z = 0
	entry.dpl = 0 // Ring 0
	entry.present = 1
	entry.gateType = 0xe // Interrupt gate
}

fun initializeFallback(entry: Pointer<IdtEntry>, fallbackHandler: UInt64) {
	var address: UInt64 = ((fallbackHandler as! UInt64))
	entry.offsetLowerbits = address & 0xffff
	entry.offsetHigherbits = (address & 0xffffffffffff0000) >> 16
	entry.selector = SYS_CODE64_SEL
	entry.zero = 0
	entry.ist = 1 // Stack
	entry.z = 0
	entry.dpl = 3 // Ring 3
	entry.present = 1
	entry.gateType = 0xe // Interrupt gate
}

let ICW1_ICW4 = 0x01		// ICW4 (not) needed
let ICW1_SINGLE = 0x02	// Single (cascade) mode
let ICW1_INTERVAL4 = 0x04 // Call address interval 4 (8)
let ICW1_LEVEL = 0x08		// Level triggered (edge) mode
let ICW1_INIT = 0x10		// Initialization - required!

let ICW4_8086 = 0x01			// 8086/88 (MCS-80/85) mode
let ICW4_AUTO = 0x02			// Auto (normal) EOI
let ICW4_BUF_SECONDARY = 0x08 // Buffered mode/secondary
let ICW4_BUF_MASTER = 0x0C	// Buffered mode/primary
let ICW4_SFNM = 0x10			// Special fully nested (not)

/*
arguments:
	offset1 - vector offset for master PIC
			vectors on the master become offset1..offset1+7
	offset2 - same for secondary PIC: offset2..offset2+7

Taken from http://wiki.osdev.org/8259_PIC
*/
fun remapPic(offset1: UInt8, offset2: UInt8) {
	serialPrintln("[cpu] begin: remap PIC")

	writePort(0x20, 0x11)
	writePort(0xA0, 0x11)
	writePort(0x21, 0x20)
	writePort(0xA1, 0x28)
	writePort(0x21, 0x04)
	writePort(0xA1, 0x02)
	writePort(0x21, 0x01)
	writePort(0xA1, 0x01)
	writePort(0x21, 0x0)
	writePort(0xA1, 0x0)

	serialPrintln("[cpu] done: remap PIC")
}

// Sets up the legacy PIC and then disables it
fun disablePic() {
	/* Set ICW1 */
	writePort(0x20, 0x11)
	writePort(0xa0, 0x11)

	/* Set ICW2 (IRQ base offsets) */
	writePort(0x21, 0xe0)
	writePort(0xa1, 0xe8)

	/* Set ICW3 */
	writePort(0x21, 4)
	writePort(0xa1, 2)

	/* Set ICW4 */
	writePort(0x21, 1)
	writePort(0xa1, 1)

	/* Set OCW1 (interrupt masks) */
	writePort(0x21, 0xff)
	writePort(0xa1, 0xff)
}

fun physicalToVirtual(physical: UInt64): UInt64 {
	var result: UInt64 = (WholePhysicalStart as! UInt64) + (physical as! UInt64)
	return result
}

// TODO check for CPU feature
fun enableLocalApic() {
	serialPrintln("[cpu] begin: enableLocalApic")

	var ptr = (UInt32 *)physicalToVirtual(0xfee000f0)
	var val: UInt32 = *ptr
	quakePrintf("APIC value is %u\n", val)

	serialPrintln("[cpu] done: enableLocalApic")
}

fun mouseWait(aType: UInt8)
fun mouseWrite(aWrite: UInt8)
fun mouseRead(): UInt8
let IRQ0 = 32
let IRQ1 = 0x21 // 33
let IRQ2 = 34
let IRQ3 = 35
let IRQ4 = 36
let IRQ5 = 37
let IRQ6 = 38
let IRQ7 = 39
let IRQ8 = 40
let IRQ9 = 41
let IRQ10 = 42
let IRQ11 = 43
let IRQ12 = 44 // 2c
let IRQ13 = 45
let IRQ14 = 46
let IRQ15 = 47

@struct @packed @sizeOf(10)
class TablePtr {
	var limit: UInt16
	var base: UInt64
}

fun lgdt(@volatile const gdt: Pointer<TablePtr>)

enum GdtType : UInt8 {
	accessed = 0x01,
	read_write = 0x02,
	conforming = 0x04,
	execute = 0x08,
	system = 0x10,
	ring1 = 0x20,
	ring2 = 0x40,
	ring3 = 0x60,
	present = 0x80
}

@struct @packed @sizeOf(8)
class GdtDescriptor {
	var limitLow: UInt16
	var baseLow: UInt16
	var baseMid: UInt8
	enum GdtType type // Access
	var size: UInt8
	var baseHigh: UInt8
}

@struct @packed @sizeOf(8)
class GdtDescriptorEx {
	UInt16 limitLow : 16
	UInt16 baseLow : 16
	UInt8 baseMid : 8
	// Access
	UInt8 accessed : 1
	UInt8 rw : 1 // 0 - read, 1 - read/write
	UInt8 direction : 1 // or conform
	// If 1 code in this segment can be executed from an equal or lower privilege level
	// If 0 code in this segment can only be executed from the ring set in "privilege"
	UInt8 execute : 1 // 1 = code, 0 = data
	UInt8 one : 1
	UInt8 privilege : 2 // 0 = ring0/kernel, 3 = ring3
	UInt8 present : 1
	// Flags
	UInt8 limit : 4
	UInt8 reserved : 2
	UInt8 zero16one32 : 1
	UInt8 blocks : 1

	UInt8 baseHigh : 8
}

@struct @packed
class TssDescriptor {
	var limitLow: UInt16
	var base_00: UInt16
	var base_16: UInt8
	enum GdtType type
	var size: UInt8
	var base_24: UInt8
	var base_32: UInt32
	var reserved: UInt32
}

@struct @packed
class TssEntry {
	var reserved0: UInt32

	var rsp[3]: UInt64 // stack pointers for CPL 0-2
	var ist[8]: UInt64 // ist[0] is reserved

	var reserved1: UInt64
	var reserved2: UInt16
	var iomap_offset: UInt16
}

@aligned(64) static @volatile TablePtr globalGdtr
@aligned(64) static @volatile TssEntry globalTss

// rsp0stack = exp0 in TSS
// Stack used by kernel to handle syscalls/interrupts
@aligned(64) UInt8 rsp0stack[4096 * 32] = {0}
@aligned(64) UInt8 rsp1stack[4096 * 32] = {0}
@aligned(64) UInt8 rsp2stack[4096 * 32] = {0}

@aligned(64) UInt8 ist0stack[4096 * 4] = {0}
@aligned(64) UInt8 ist1stack[4096 * 4] = {0}
@aligned(64) UInt8 ist2stack[4096 * 4] = {0}
@aligned(64) UInt8 ist3stack[4096 * 4] = {0}
@aligned(64) UInt8 ist4stack[4096 * 4] = {0}
@aligned(64) UInt8 ist5stack[4096 * 4] = {0}
@aligned(64) UInt8 ist6stack[4096 * 4] = {0}
@aligned(64) UInt8 ist7stack[4096 * 4] = {0}

// LLVM did the magic expected of it. It only saved registers that are clobbered by your fun (hence rax).
// All other register are left unchanged hence thereâ€™s no need of saving and restoring them.
// https://github.com/phil-opp/blog_os/issues/450#issuecomment-582535783

// TODO: errcode is `extra` here:
//@aligned(64) @interrupt Void unknownInterrupt(struct frame: Pointer<InterruptFrame>,
// uint64_t
// extra) {
// https://github.com/llvm-mirror/clang/blob/master/test/SemaCXX/attr-x86-interrupt.cpp#L30
Void anyInterruptHandler(frame: Pointer<InterruptFrame>)

// TODO remove
@aligned(64) @interrupt Void unknownInterrupt(frame: Pointer<InterruptFrame>) {
	// TODO Find a better way to avoid LLVM bugs
	anyInterruptHandler(frame)
}

Void anyInterruptHandler(frame: Pointer<InterruptFrame>) {
	amd64.disableAllInterrupts()
#if false
	let stack = (InterruptStack *)((frame as! UInt64) - 200)

#end

	// Enable interrupts
	writePort(0xA0, 0x20)
	writePort(PIC1_COMMAND_0x20, PIC_EOI_0x20)

	// Operating systems use some of the segments for internal usage.
	// For instance GS register to access the TLS (thread local storage)
	// and in Linux it's for accessing cpu specific memory
}

// ~121 times per second
var timerCalled: UInt64 = 0

const UInt64 stackSizeForKernelThread = 1024 * 1024

fun kernelThread()
@aligned(64) UInt8 kernelStack[stackSizeForKernelThread] = {0}

InterruptFrame guiThreadFrame
fun guiThread()
@aligned(64) UInt8 guiStack[stackSizeForKernelThread] = {0}

@extern "C" Void timerInterruptHandler(@volatile frame: Pointer<InterruptFrame>)

var extraMillisecond: UInt8 = 0
var taskBarRedraw: UInt8 = 0 // Re-paint task bar current time
@volatile Bool nextIsUserProcess = false
@volatile Bool nextIsGuiThread = true

fun getNextProcess(): UInt64 {
	var index: UInt64 = 1
	while (index < 255) {
		if (process.processes[index].present == true) {
			if (process.processes[index].schedulable == true)
				if (process.processes[index].scheduleOnNextTick == true)
					return index
		}
		index++
	}

	return 0 // Idle
}

fun markAllProcessessSchedulable() {
	var index: UInt64 = 0
	while (index < 255) { // TODO 256?
		if (process.processes[index].present == true) {
			if (process.processes[index].schedulable == true)
				process.processes[index].scheduleOnNextTick = true
		}
		index++
	}
}

fun switchToKernelThread(@volatile frame: Pointer<InterruptFrame>) {
	if (currentThread == THREAD_KERNEL)
		return

	if (currentThread == THREAD_USER) {
		// Save
		var process: Pointer<process.Process> = Pointer.of(process.processes[process.currentProcess])
		tmemcpy(Pointer.of(process.frame), frame, sizeof(InterruptFrame))
	} else if (currentThread == THREAD_GUI) {
		// Save
		tmemcpy(Pointer.of(guiThreadFrame), frame, sizeof(InterruptFrame))
	}

	// Restore
	currentThread = THREAD_KERNEL
	amd64.writeCr3((pml4kernelThread as! UInt64) - (WholePhysicalStart as! UInt64))
	tmemcpy(frame, Pointer.of(kernelThreadFrame), sizeof(InterruptFrame))
}

fun switchToNextProcess(@volatile frame: Pointer<InterruptFrame>) {
	@volatile var next = getNextProcess()

	if (next == 0) {
		markAllProcessessSchedulable()
		next = getNextProcess()
	}

	var process: Pointer<process.Process> = Pointer.of(process.processes[next])
	@volatile let old = process.currentProcess
	process.currentProcess = process.pid
	// TODO in .exe loader, disallow changing of CR3 until not fully loaded
	// another option is to save/restore CR3 used by kernel thread
	amd64.writeCr3((process.pml4 as! UInt64) - (WholePhysicalStart as! UInt64))
	process.scheduleOnNextTick = false

	// Note: pid 0 is not real process, so keep things in kernel
	if (next != 0) {
		if (currentThread == THREAD_GUI) {
			// Save
			tmemcpy(Pointer.of(guiThreadFrame), frame, sizeof(InterruptFrame))
		} else if (currentThread == THREAD_USER) {
			// Save
			var processOld: Pointer<process.Process> = Pointer.of(process.processes[old])
			tmemcpy(Pointer.of(processOld.frame), frame, sizeof(InterruptFrame))
		} else if (currentThread == THREAD_KERNEL) {
			// Save
			tmemcpy(Pointer.of(kernelThreadFrame), frame, sizeof(InterruptFrame))
		}

		// Restore
		currentThread = THREAD_USER
		tmemcpy(frame, Pointer.of(process.frame), sizeof(InterruptFrame))
	} else {
		amd64.writeCr3((pml4kernelThread as! UInt64) - (WholePhysicalStart as! UInt64))
		switchToKernelThread(frame)
	}
}

fun switchToGuiThread(@volatile frame: Pointer<InterruptFrame>) {
	if (currentThread == THREAD_GUI)
		return

	if (currentThread == THREAD_USER) {
		// Save
		var process: Pointer<process.Process> = Pointer.of(process.processes[process.currentProcess])
		tmemcpy(Pointer.of(process.frame), frame, sizeof(InterruptFrame))
	} else if (currentThread == THREAD_KERNEL) {
		// Save
		tmemcpy(Pointer.of(kernelThreadFrame), frame, sizeof(InterruptFrame))
	}

	// Restore
	currentThread = THREAD_GUI
	tmemcpy(frame, Pointer.of(guiThreadFrame), sizeof(InterruptFrame))
}

Void yieldInterruptHandler(@volatile frame: Pointer<InterruptFrame>) {
	amd64.disableAllInterrupts()
	switchToNextProcess(frame)
}

Void timerInterruptHandler(@volatile frame: Pointer<InterruptFrame>) {
	amd64.disableAllInterrupts()

	if (timerCalled % 121 == 0) {
		taskBarRedraw++
		if (taskBarRedraw > 30) {
			haveToRender = 1
			taskBarRedraw = 0
		}
	}
	uptimeMilliseconds += 8
	if (extraMillisecond % 4 == 0) {
		uptimeMilliseconds += 1 // PIT is somewhat imprecise
	}
	if (extraMillisecond % 64 == 0) {
		uptimeMilliseconds += 1 // PIT is somewhat imprecise
	}
	extraMillisecond++
	timerCalled++

	// Schedule
	if (true) {
		if (currentThread == THREAD_INIT) {
			// TODO hexa error == statement: currentThread == THREAD_INIT
			guiThreadFrame.flags = frame.flags // TODO
			kernelThreadFrame.flags = frame.flags // TODO

			// Restore
			currentThread = THREAD_GUI
			tmemcpy(frame, Pointer.of(guiThreadFrame), sizeof(InterruptFrame))
		} else {
			if (currentThread == THREAD_GUI) {
				// Just give it enough time to fimish rendering
				// It will schedule to other process on finish
				nextIsGuiThread = false
			} else {
				if (nextIsGuiThread == true) {
					nextIsGuiThread = false
					switchToGuiThread(frame)
				} else {
					nextIsGuiThread = true
					if (nextIsUserProcess == true) {
						switchToKernelThread(frame)
					} else {
						switchToNextProcess(frame)
					}
					nextIsUserProcess = !nextIsUserProcess
				}
			}
		}
	}
	//		if (currentThread == THREAD_INIT) {
	//			// TODO hexa error == statement: currentThread == THREAD_INIT

	// Enable interrupts
	writePort(PIC1_COMMAND_0x20, PIC_EOI_0x20)
}

fun syscallInterruptHandler(frame: Pointer<InterruptFrame>) {
	amd64.disableAllInterrupts()
	@volatile process.Process *process = Pointer.of(process.processes[process.currentProcess])
	process.schedulable = false
	@volatile let index = (TofitaSyscalls)frame.rcxArg0

	// No-op
	if ((index as! UInt64) < USER_SYSCALLS) {
		process.schedulable = true
		return
	}

	process.syscallToHandle = index

	switchToKernelThread(frame)
	// TODO weird frame+8 offset if called switchToNextProcess
	// switchToNextProcess(frame)
	return

	if (index == TofitaSyscalls.DebugLog) {
		serialPrintf("[[DebugLog:PID %d]] %s\n", process.currentProcess, frame.rdxArg1)
		return
	}

	if (index == TofitaSyscalls.ExitProcess) {
		serialPrintf("[[ExitProcess:PID %d]] %d\n", process.currentProcess, frame.rdxArg1)
		// TODO kernel wakeup
		// TODO destroy process
		var process: Pointer<process.Process> = Pointer.of(process.processes[process.currentProcess])
		process.schedulable = false
		switchToNextProcess(frame)
		process.present = false
		return
	}
}

fun setTsr(@volatile UInt16 tsr_data)

// 16 records
@aligned(64) static UInt32 gdtTemplate[32] = {
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00209b00, 0x0000ffff, 0x00cf9300,
	0x0000ffff, 0x00cffa00, 0x0000ffff, 0x00cff300, 0x00000000, 0x0020fb00, 0x00000000, 0x00000000,
	0x60800067, 0x00008bb9, 0xfffff800, 0x00000000, 0xe0003c00, 0xff40f3fa, 0x00000000, 0x00000000,
	0x0000ffff, 0x00cf9a00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}

let PS2_DATA_PORT = 0x60
let PS2_CONTROL_PORT = 0x64

fun gdtSetEntry(i: UInt8, base: UInt32, limit: UInt64, is64: Bool, enum GdtType typed) {
	var gdtd: Pointer<GdtDescriptor> = (GdtDescriptor *)Pointer.of(gdtTemplate[i * 2])
	gdtd.limitLow = limit & 0xffff
	gdtd.size = (limit >> 16) & 0xf
	// gdtd.size |= (is64 ? 0xa0 : 0xc0)
	gdtd.size |= 0xa0
	gdtd.size <<= 0x0D // Long mode

	gdtd.baseLow = base & 0xffff
	gdtd.baseMid = (base >> 16) & 0xff
	gdtd.baseHigh = (base >> 24) & 0xff

	gdtd.type = (enum GdtType)(typed | system | present)
}

// Takes 2 GDT entries
fun tssSetEntry(i: UInt8, base: UInt64, limit: UInt64) {
	var tssd: Pointer<TssDescriptor> = (TssDescriptor *)Pointer.of(gdtTemplate[i * 2])
	tssd.limitLow = limit & 0xffff
	tssd.size = (limit >> 16) & 0xf

	tssd.base_00 = base & 0xffff
	tssd.base_16 = (base >> 16) & 0xff
	tssd.base_24 = (base >> 24) & 0xff
	tssd.base_32 = (base >> 32) & 0xffffffff
	tssd.reserved = 0

	tssd.type = (enum GdtType)(accessed | execute | ring3 | // TODO
								present)
}

@aligned(64) Idtr cacheIdtr

fun dumpGDT(desc: Pointer<GdtDescriptorEx>) {
	serialPrintf("[dumpGDT]")

	if (desc.accessed)
		serialPrintf(" accessed")
	if (desc.rw)
		serialPrintf(" rw")
	if (desc.direction)
		serialPrintf(" direction")
	if (desc.execute)
		serialPrintf(" execute")
	if (desc.one)
		serialPrintf(" one")

	if (desc.privilege == 0)
		serialPrintf(" privilege=ring0")
	if (desc.privilege == 1)
		serialPrintf(" privilege=ring1")
	if (desc.privilege == 2)
		serialPrintf(" privilege=ring2")
	if (desc.privilege == 3)
		serialPrintf(" privilege=ring3")

	if (desc.present)
		serialPrintf(" present")
	if (desc.zero16one32)
		serialPrintf(" zero16one32")
	if (desc.blocks)
		serialPrintf(" pages")

	serialPrintf("\n")
}

fun enableInterrupts() {
	serialPrintln("[cpu] initializing lgdt")

	var sizeof_TssEntry: UInt64 = sizeof(globalTss)
	serialPrintf("[cpu] sizeof_TssEntry 104 = %u == %u\n", sizeof_TssEntry, sizeof(TssEntry))

	memset((Void *)Pointer.of(globalTss), 0, sizeof_TssEntry)
	globalTss.iomap_offset = sizeof_TssEntry
	globalTss.rsp[0] = (uint64_t)Pointer.of(rsp0stack)
	globalTss.rsp[1] = (uint64_t)Pointer.of(rsp1stack)
	globalTss.rsp[2] = (uint64_t)Pointer.of(rsp2stack)
	// TODO zero out stacks
	// TODO more stacks
	globalTss.ist[0] = (uint64_t)Pointer.of(ist0stack)
	globalTss.ist[1] = (uint64_t)Pointer.of(ist1stack)
	globalTss.ist[2] = (uint64_t)Pointer.of(ist2stack)
	globalTss.ist[3] = (uint64_t)Pointer.of(ist3stack)
	globalTss.ist[4] = (uint64_t)Pointer.of(ist4stack)
	globalTss.ist[5] = (uint64_t)Pointer.of(ist5stack)
	globalTss.ist[6] = (uint64_t)Pointer.of(ist6stack)
	globalTss.ist[7] = (uint64_t)Pointer.of(ist7stack)

	serialPrint("[cpu] RSP[0] points to: ")
	serialPrintHex((globalTss.rsp[0] as! UInt64))
	serialPrint("\n")

	serialPrint("[cpu] RSP[1] points to: ")
	serialPrintHex((globalTss.rsp[1] as! UInt64))
	serialPrint("\n")

	serialPrint("[cpu] RSP[2] points to: ")
	serialPrintHex((globalTss.rsp[2] as! UInt64))
	serialPrint("\n")

	var tssBase: UInt64 = (uint64_t)(Pointer.of(globalTss))

	// upload
	{
		tssSetEntry(8, tssBase, sizeof_TssEntry)
		// tssSetEntry(8, tssBase, sizeof_TssEntry - 1); TODO
	}

	if (false) {
		let gdt = (GdtDescriptorEx *)gdtTemplate
		for (UInt32 i = 0; i < 16; ++i) {
			if (i == 0)
				continue // Empty
			if (i == 8)
				continue // TSS
			if (i == 9)
				continue // TSS
			if (gdt[i].present == 0)
				continue
			serialPrintf("[dumpGDT] #%u\n", i)
			dumpGDT(Pointer.of(gdt[i]))
		}
	}

	globalGdtr.limit = sizeof(gdtTemplate) - 1
	globalGdtr.base = (uint64_t)(Pointer.of(gdtTemplate[0]))
	serialPrint("[cpu] GDTR points to: ")
	serialPrintHex((uint64_t)Pointer.of(globalGdtr))
	serialPrint("\n")
	serialPrint("[cpu] GDT points to: ")
	serialPrintHex((globalGdtr.base as! UInt64))
	serialPrint("\n")
	serialPrintf("[cpu] GDT size is %u == %u\n", globalGdtr.limit, 0x7F)
	serialPrintln("[cpu] calling lgdt")
	lgdt(Pointer.of(globalGdtr))
	serialPrintln("[cpu] calling ltr")
	{
		setTsr(64)
		// setTsr(64 + 3)
	}

	serialPrintln("[cpu] initializing unknownInterrupt")

	for (UInt32 i = 0; i < 286; ++i) {
		initializeFallback(&IDT[i], (uint64_t)Pointer.of(unknownInterrupt))
	}

	// CPU exceptions
	initializeFallback(&IDT[0x00], (uint64_t)Pointer.of(cpu0x00))
	initializeFallback(&IDT[0x01], (uint64_t)Pointer.of(cpu0x01))
	initializeFallback(&IDT[0x02], (uint64_t)Pointer.of(cpu0x02))
	initializeFallback(&IDT[0x03], (uint64_t)Pointer.of(cpu0x03))
	initializeFallback(&IDT[0x04], (uint64_t)Pointer.of(cpu0x04))
	initializeFallback(&IDT[0x05], (uint64_t)Pointer.of(cpu0x05))
	initializeFallback(&IDT[0x06], (uint64_t)Pointer.of(cpu0x06))
	initializeFallback(&IDT[0x07], (uint64_t)Pointer.of(cpu0x07))
	initializeFallback(&IDT[0x08], (uint64_t)Pointer.of(cpu0x08))
	initializeFallback(&IDT[0x09], (uint64_t)Pointer.of(cpu0x09))
	initializeFallback(&IDT[0x0A], (uint64_t)Pointer.of(cpu0x0A))
	initializeFallback(&IDT[0x0B], (uint64_t)Pointer.of(cpu0x0B))
	initializeFallback(&IDT[0x0C], (uint64_t)Pointer.of(cpu0x0C))
	initializeFallback(&IDT[0x0D], (uint64_t)Pointer.of(cpu0x0D))
	initializeFallback(&IDT[0x0E], (uint64_t)Pointer.of(cpu0x0E))
	initializeFallback(&IDT[0x0F], (uint64_t)Pointer.of(cpu0x0F))
	initializeFallback(&IDT[0x10], (uint64_t)Pointer.of(cpu0x10))
	initializeFallback(&IDT[0x11], (uint64_t)Pointer.of(cpu0x11))
	initializeFallback(&IDT[0x12], (uint64_t)Pointer.of(cpu0x12))
	initializeFallback(&IDT[0x13], (uint64_t)Pointer.of(cpu0x13))
	initializeFallback(&IDT[0x14], (uint64_t)Pointer.of(cpu0x14))
	initializeFallback(&IDT[0x15], (uint64_t)Pointer.of(cpu0x15))

	// PIC interrupts
	initializeFallback(&IDT[IRQ0], (uint64_t)(Pointer.of(timerInterrupt)))
	initializeKeyboard(&IDT[IRQ1])
	initializeMouse(&IDT[IRQ12])

	// Syscalls
	initializeFallback(&IDT[0x80], (uint64_t)(Pointer.of(syscallInterrupt)))
	initializeFallback(&IDT[0x81], (uint64_t)(Pointer.of(yieldInterrupt)))

	cacheIdtr.limit = (sizeof(IdtEntry) * IDT_SIZE) - 1
	cacheIdtr.offset = (IDT as! UInt64)

	serialPrint("[cpu] IDTR points to: ")
	serialPrintHex((uint64_t)Pointer.of(cacheIdtr))
	serialPrint("\n")
	serialPrint("[cpu] IDT points to: ")
	serialPrintHex((uint64_t)&IDT)
	serialPrint("\n")
	serialPrintf("[cpu] IDT size is %u of %u elements of %u==16 size\n", cacheIdtr.limit, IDT_SIZE,
				 sizeof(IdtEntry))
	serialPrintln("[cpu] loading IDTR")
	// Before you implement the IDT, make sure you have a working GDT
	remapPic(0x20, 0x28)
	serialPrintln("[cpu] calling lidtq")
	loadIdt(Pointer.of(cacheIdtr))

	serialPrintln("[cpu] Select segments of value SYS_CODE64_SEL & SYS_DATA32_SEL")
	enterKernelMode()

	// Set PIT frequency
	// Valid values: 57 Hz, 121 Hz, 173 Hz
	// Next valid: `i = 174; while (Math.round(1193181 / i) != (1193181 / i)) {i++;}; console.log(i)`
	writePort(0x43, 0x36)
	let frequency = 1193181 / 121
	writePort(0x40, frequency & 0xFF)
	writePort(0x40, (frequency >> 8) & 0xFF)

	// Unmasking IRQ to support all the things
	// but NOT keyboard
	writePort(IRQ1, 0x00 | 0b00000010)
	// 0xFA - timer
	// 0xFC - timer and kb
	// 0xFD - kb
	// 0xFE - timer
	// 0xFF - none
}

fun enablePS2Mouse() {
	serialPrintln("[cpu] begin: setting PS/2 mouse")
	UInt8 _status
	// Enable the auxiliary mouse device
	mouseWait(1)
	writePort(PS2_CONTROL_PORT, 0xA8)

	/*

	IOWriteB(PS2_CONTROL_PORT, 0x20)
	ControllerConfig = IOReadB(PS2_DATA_PORT)
	ControllerConfig |=  0x02 // Turn on IRQ12
	ControllerConfig &= ~0x20 // Enable mouse clock line
	IOWriteB(PS2_CONTROL_PORT, 0x60)

	*/

	// Enable the interrupts
	mouseWait(1)
	writePort(PS2_CONTROL_PORT, 0x20)
	mouseWait(0)
	_status = (readPort(PS2_DATA_PORT) | 2) // Turn on IRQ12
	//_status &= ~0x20 // Enable mouse clock line
	mouseWait(1)
	writePort(PS2_CONTROL_PORT, 0x60)
	mouseWait(1)
	writePort(PS2_DATA_PORT, _status)
	// Tell the mouse to use default settings
	mouseWrite(0xF6)
	mouseRead() // Acknowledge
	// Enable the mouse
	mouseWrite(0xF4)
	mouseRead() // Acknowledge
	// Setup the mouse handler
	// irq_install_handler(12, mouseHandler)
	serialPrintln("[cpu] done: setting PS/2 mouse")
	fun quakePrintf(const c: Pointer<WideChar>, ...)
	quakePrintf("Enabled PS/2 mouse and keyboard\n")
}

fun mouseWait(@volatile UInt8 aType) {
	@volatile UInt32 _timeOut = 1000000
	if (aType == 0) {
		while (_timeOut--) // Data
		{
			if ((readPort(PS2_CONTROL_PORT) & 1) == 1) {
				return
			}
		}
		return
	} else {
		while (_timeOut--) // Signal
		{
			if ((readPort(PS2_CONTROL_PORT) & 2) == 0) {
				return
			}
		}
		return
	}
}

fun mouseWrite(@volatile UInt8 aWrite) {
	// Wait to be able to send a command
	mouseWait(1)
	// Tell the mouse we are sending a command
	writePort(PS2_CONTROL_PORT, 0xD4)
	// Wait for the final part
	mouseWait(1)
	// Finally write
	writePort(PS2_DATA_PORT, aWrite)
}

fun mouseRead(): UInt8 {
	// Get's response from mouse
	mouseWait(0)
	return readPort(PS2_DATA_PORT)
}
