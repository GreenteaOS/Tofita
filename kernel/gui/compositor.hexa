// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Performs screen composition of all user interface

// Note: ACCURACY is PREFERRED over SPEED, that's why we do full 2D composition even without GPU

// Differential composition is not yet supported, performance with large amount of apps may be low

var wallpaper: Bitmap32 = null // Size of framebuffer
var vibranceLight: Bitmap32 = null // Size of framebuffer
var vibranceDark: Bitmap32 = null // Size of framebuffer
var leaves: Bitmap32 = null
var trashCan: Bitmap32 = null
var notepad16: Bitmap32 = null
var notepad48: Bitmap32 = null
var link: Bitmap32 = null
var cur: Cursor = null

var startupAnimation: UInt16 = 0

enum WallpaperStyle : UInt8 {
	Center
	Stretch
	Fill
	// TODO more options
}

fun setWallpaper(bitmap: Bitmap32, style: WallpaperStyle) {
	var bitmap = bitmap

	{
		serialPrintln("[compositor.setWallpaper] upscale wallpaper to screen size")
		var upscale: Bitmap32 = allocateBitmap(_framebuffer.width, _framebuffer.height)

		let hReciprocal = 1.0f32 / (_framebuffer.height as! Float32)
		let wReciprocal = 1.0f32 / (_framebuffer.width as! Float32)

		for y in upscale.height {
			for x in upscale.width {
				var rgba = interpolatePixel(
					bitmap,
					(x * wReciprocal) * bitmap.width as! Float32, // TODO `as! _` or something
					(y * hReciprocal) * (bitmap.height - 8) as! Float32
				)
				upscale.pixels[y * upscale.width + x].ref.rgba.ref.r = rgba.ref.r
				upscale.pixels[y * upscale.width + x].ref.rgba.ref.g = rgba.ref.g
				upscale.pixels[y * upscale.width + x].ref.rgba.ref.b = rgba.ref.b
			}
		}

		wallpaper = upscale
		bitmap = wallpaper
	}

	serialPrintln("[compositor.setWallpaper] downscale 8x")

	var blurScale: UInt8 = 8

	var downscale: Bitmap32 = allocateBitmap(
		bitmap.width / blurScale - 1u32, // TODO infer int types, also integer division
		bitmap.height / blurScale - 1u32 + 8
	)

	for y in downscale.height - 8 {
		for x in downscale.width {
			downscale.pixels[y * downscale.width + x].ref.color =
				bitmap.pixels[y * bitmap.width * blurScale + x * blurScale].ref.color
		}
	}

	// Fix
	for y in downscale.height - 8 ... downscale.height {
		for x in downscale.width {
			downscale.pixels[y * downscale.width + x].ref.color =
				bitmap.pixels[bitmap.width * (bitmap.height - 1) + x * blurScale].ref.color
		}
	}

	serialPrintln("[compositor.setWallpaper] blur")

	var blur: Bitmap32 = gaussBlur(downscale, 4)

	serialPrintln("[compositor.setWallpaper] upscale 8x")

	// Upscale
	var upscaleLight: Bitmap32 = allocateBitmap(bitmap.width, bitmap.height)
	var upscaleDark: Bitmap32 = allocateBitmap(bitmap.width, bitmap.height)
	var upscale: Bitmap32 = upscaleDark

	let hReciprocal = 1.0f32 / (upscale.height as! Float32)
	let wReciprocal = 1.0f32 / (upscale.width as! Float32)

	for y in upscale.height as! UInt64 {
		for x in upscale.width as! UInt64 {
			let rgbaSource =
				interpolatePixel(
					downscale,
					(x * wReciprocal) * downscale.width as! Float32, // TODO UInt32 is precise than Float32
					(y * hReciprocal) * (downscale.height - 8) as! Float32
				)
			// Apply vibrance (frosted glass)
			// 0.66*255 = 168.3
			/// rgba.r = Blend255(rgba.r, 255, 168)
			/// rgba.g = Blend255(rgba.g, 255, 168)
			/// rgba.b = Blend255(rgba.b, 255, 168)

			{
				var rgba = rgbaSource
				var rgba = rgba.ref
				rgba.r = blend255(rgba.r, 0, 168)
				rgba.g = blend255(rgba.g, 0, 168)
				rgba.b = blend255(rgba.b, 0, 168)
				// TODO upscaleDark.pixels[y * upscale.width + x].ref.rgba = rgba
				upscaleDark.pixels[y * upscale.width + x].ref.rgba.ref.r = rgba.r
				upscaleDark.pixels[y * upscale.width + x].ref.rgba.ref.g = rgba.g
				upscaleDark.pixels[y * upscale.width + x].ref.rgba.ref.b = rgba.b
			}

			{
				var rgba = rgbaSource
				var rgba = rgba.ref
				rgba.r = blend255(rgba.r, 255, 168)
				rgba.g = blend255(rgba.g, 255, 168)
				rgba.b = blend255(rgba.b, 255, 168)
				// TODO upscaleLight.pixels[y * upscale.width + x].ref.rgba = rgba
				upscaleLight.pixels[y * upscale.width + x].ref.rgba.ref.r = rgba.r
				upscaleLight.pixels[y * upscale.width + x].ref.rgba.ref.g = rgba.g
				upscaleLight.pixels[y * upscale.width + x].ref.rgba.ref.b = rgba.b
			}
		}
	}

	vibranceDark = upscaleDark
	vibranceLight = upscaleLight
}

fun drawVibrancedRectangle(x: Int16, y: Int16, width: UInt16, height: UInt16, dark: Bool = true) {
	let vibrance = dark ? vibranceDark : vibranceLight // Avoit non-register global access
	for yy in height {
		for xx in width {
			if x + xx < 0 {
				continue
			}
			if x + xx > vibrance.width {
				continue
			}
			if y + yy < 0 {
				continue
			}
			if y + yy > vibrance.height {
				continue
			}
			var pixel: UInt32 = (y + yy) * vibrance.width + xx + x as! UInt32
			setPixel(x + xx, y + yy, vibrance.pixels[pixel])
		}
	}
}

var doublebuffer: Bitmap32 = null
fun initializeCompositor() {
	serialPrintln("[compositor.initializeCompositor] begin")
	doublebuffer = allocateBitmap(_framebuffer.width, _framebuffer.height)
	_pixels = doublebuffer.pixels

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/leaves.png")
	leaves = loadPng32(a)

	let b = new RamDiskAsset()
	getRamDiskAsset(b, "root/Windows/Resources/Icons/trash-empty48.png")
	trashCan = loadPng32(b)

	let c = new RamDiskAsset()
	getRamDiskAsset(c, "root/Windows/Resources/Icons/notepad.ico_48x48.png")
	notepad48 = loadPng32(c)

	let d = new RamDiskAsset()
	getRamDiskAsset(d, "root/Windows/Resources/Icons/notepad.ico_16x16.png")
	notepad16 = loadPng32(d)

	let e = new RamDiskAsset()
	getRamDiskAsset(e, "root/Windows/Resources/Icons/link.png")
	link = loadPng32(e)

	let asset = new RamDiskAsset()
	getRamDiskAsset(asset, "root/Windows/Cursors/aero_arrow.cur")
	// TODO cur = loadCursor(Buffer.fromBytes(asset.data))
	cur = loadCursor(asset)

	serialPrintln("[compositor.initializeCompositor] done")
}

fun compositeWindows() {
	var i = rootWindow
	// Avoid infinite loop
	for loop in windowsLimit {
		let window = windowsList[i]

		// TODO proper iteration
		if window == null {
			continue
		}

		if i != 0 && window.present && window.visible {
			let hover = frameHoverWindow == i ? frameHoverState : FrameHover.Noop

			drawWindowFrame(
				window.title,
				window.x,
				window.y,
				window.width + 2,
				window.height + 34,
				firstResponder == i,
				hover,
				frameHoverWindowDown
			)

			// TODO just untyped `let frameHeight = 30 + 3`, see below
			// TODO also `let frameHeight: Int16 = 30 + 3`
			let frameHeight: Int16 = 30 + 3i16
			let frameWidth: Int16 = 1i16

			if window.fbZeta != null && window.fbGama != null {

				drawBitmap32(window.fbCurrentZeta ? window.fbZeta : window.fbGama, window.x + frameWidth,
							 window.y + frameHeight)
			} else {
				drawVibrancedRectangle(
					window.x + frameWidth, // TODO late-infer-fix int type
					window.y + frameHeight,
					window.width,
					window.height,
					true
				)
			}
		}

		i = windowsList[i].nextId
		if i == 0 {
			break
		}
	}
}

fun composite(startupMilliseconds: UInt64) {
	// TODO not best place for this
	handleMouseActivity()
	handleKeyboardActivity()

	let mouseX = mouseX
	let mouseY = mouseY

	// Startup animation
	if startupAnimation < 2000 {
		haveToRender = true
		startupAnimation += 9 * 2u16
	}

	drawBitmap32(wallpaper, 0, 0)
	drawBitmap32WithAlpha(trashCan, 12i16, 10i16)
	var color = new ByValue<Pixel32>()
	color.ref.color = 0x00000000
	drawShadowText("Recycle Bin", 8, 62i16) // TODO infer i16
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8
	drawAsciiText("Recycle Bin", 8, 62i16, color.ref)

	color.ref.rgba.ref.a = 64
	if mouseX > 20 && mouseX < (20 + 32) && mouseY > 12 && mouseY < (12 + 60) {
		let outlineX = 1i16
		let outlineY = 10i16
		let outlineW = 72u16
		let outlineH = 64u16
		drawRectangleWithAlpha(color.ref, outlineX, outlineY, outlineW, outlineH)
		drawRectangleOutline(color, outlineX, outlineY, outlineW, outlineH)
	}

	// Desktop below everything
	compositeDesktop(mouseX, mouseY)

	// Windows below taskbar
	compositeWindows()

	// Taskbar
	let animationTaskbarY = Math.min(startupAnimation / 1555.0, 1.0) * 30
	drawVibrancedRectangle(
		0,
		_framebuffer.height - animationTaskbarY as! Int16, // TODO upcast `a - b` to larger type
		_framebuffer.width as! UInt16,
		30
	)

	let taskbarY = _framebuffer.height + 30 - animationTaskbarY * 2.0
	let taskbarY = taskbarY as! Int16

	// Start button
	color.ref.rgba.ref.a = 128
	color.ref.rgba.ref.a = 100
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0x61u8
	if mouseX < 40 && mouseY > (_framebuffer.height - 30) {
		drawRectangleWithAlpha(color.ref, 0, taskbarY, 40, 30)
	}
	drawBitmap32WithAlpha(leaves, 2i16, taskbarY + 2i16)

	// Taskbar shortcuts
	let shortcutsStart = 5 + 36 + 4i16
	drawBitmap32WithAlpha(notepad16, shortcutsStart, taskbarY + 7i16)

	// Tray | line
	color.ref.color = 0x00000000
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0x66u8
	drawRectangle(color, _framebuffer.width - 4i16, taskbarY, 1, 30)

	var trayButtonX = _framebuffer.width - 20 - 16i16
	trayButtonX = _framebuffer.width - 80i16
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0x11u8
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8

	let timeMilliseconds = uptimeMilliseconds + startupMilliseconds
	var uptimeHours = (timeMilliseconds / (60 * 60 * 1000)) as! Int64
	while uptimeHours >= 24 {
		uptimeHours -= 24
	}
	let uptimeMinutes = ((timeMilliseconds - (uptimeHours * (60 * 60 * 1000))) / (60 * 1000)) as! UInt8

	var pm: Bool = uptimeHours >= 12
	if uptimeHours > 12 {
		uptimeHours -= 12
	}

	var trayTimeX = trayButtonX + 20
	trayTimeX += drawIntegerText(uptimeHours, trayTimeX, taskbarY + 10i16, color.ref)
	trayTimeX += drawAsciiText(":", trayTimeX, taskbarY + 10i16, color.ref)
	if uptimeMinutes < 10 {
		trayTimeX += drawAsciiText("0", trayTimeX, taskbarY + 10i16, color.ref)
	}
	trayTimeX += drawIntegerText(uptimeMinutes, trayTimeX, taskbarY + 10i16, color.ref)
	trayTimeX += drawAsciiText(pm ? " PM" : " AM", trayTimeX, taskbarY + 10i16, color.ref)

	line45smooth(color, trayButtonX, taskbarY + 10 + 2i16, 6i16, 1i16)
	line45smooth(color, trayButtonX + 1i16, taskbarY + 10 + 2i16, 6i16, -1i16)

	drawCursor(cur, mouseX as! UInt16, mouseY as! UInt16)
	quake()
}

fun copyToScreen() {
	// On 64-bit platform registers are 64-bit,
	// so lets copy two pixels at a time
	let height = _framebuffer.height
	// Let's assume it is always divideable by 2
	let width = _framebuffer.width / 2
	let scanline: UInt64 = _framebuffer.width * 4
	let pixelsPerScanLine: UInt64 = _framebuffer.pixelsPerScanLine * 4
	var source = (_pixels as! UInt64) as! ArrayPointer<UInt64>
	var destination = (_framebuffer.base as! UInt64) as! ArrayPointer<UInt64>

	for y in height {
		for x in width {
			destination[x] = source[x]
		}

		source = ((source as! UInt64) + scanline) as! ArrayPointer<UInt64>
		destination = ((destination as! UInt64) + pixelsPerScanLine) as! ArrayPointer<UInt64>
	}
}
