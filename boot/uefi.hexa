// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// UEFI bindings
// Based on public EFI header files aka GNU-EFI

declare INTN = Int64 // TODO
declare UINTN = UInt64 // TODO
declare EFI_PHYSICAL_ADDRESS = UInt64

@struct class EFI_GUID {
	let data1: UInt32
	let data2: UInt16
	let data3: UInt16
	let data41: UInt8
	let data42: UInt8
	let data43: UInt8
	let data44: UInt8
	let data45: UInt8
	let data46: UInt8
	let data47: UInt8
	let data48: UInt8

	fun areSame(other: EFI_GUID): Bool {
		return
			this.data1 == other.data1 and
			this.data2 == other.data2 and
			this.data3 == other.data3 and
			this.data41 == other.data41 and
			this.data42 == other.data42 and
			this.data43 == other.data43 and
			this.data44 == other.data44 and
			this.data45 == other.data45 and
			this.data46 == other.data46 and
			this.data47 == other.data47 and
			this.data48 == other.data48
	}
}

// TODO type should infer `@struct` from parent class
@struct
class ACPI_20_TABLE_GUID extends EFI_GUID {
	let data1: UInt32 = 0x8868e871u32
	let data2: UInt16 = 0xe4f1u16
	let data3: UInt16 = 0x11d3u16
	let data41: UInt8 = 0xbcu8
	// TODO `0xbc_u8`
	let data42: UInt8 = 0x22u8
	let data43: UInt8 = 0x0u8
	let data44: UInt8 = 0x80u8
	let data45: UInt8 = 0xc7u8
	let data46: UInt8 = 0x3cu8
	let data47: UInt8 = 0x88u8
	let data48: UInt8 = 0x81u8
	new () {}
}

@struct
class ACPI_TABLE_GUID extends EFI_GUID {
	let data1: UInt32 = 0xeb9d2d30u32
	let data2: UInt16 = 0x2d88u16
	let data3: UInt16 = 0x11d3u16
	let data41: UInt8 = 0x9au8
	// TODO `0xbc_u8`
	let data42: UInt8 = 0x16u8
	let data43: UInt8 = 0x0u8
	let data44: UInt8 = 0x90u8
	let data45: UInt8 = 0x27u8
	let data46: UInt8 = 0x3fu8
	let data47: UInt8 = 0xc1u8
	let data48: UInt8 = 0x4du8
	new () {}
}

@struct
class EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID extends EFI_GUID {

	let data1: UInt32 = 0x9042a9deu32
	let data2: UInt16 = 0x23dcu16
	let data3: UInt16 = 0x4a38u16
	let data41: UInt8 = 0x96u8
	// TODO `0xbc_u8`
	let data42: UInt8 = 0xfbu8
	let data43: UInt8 = 0x7au8
	let data44: UInt8 = 0xdeu8
	let data45: UInt8 = 0xd0u8
	let data46: UInt8 = 0x80u8
	let data47: UInt8 = 0x51u8
	let data48: UInt8 = 0x6au8
	new () {}
}

@struct
class EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID extends EFI_GUID {

	let data1: UInt32 = 0x964e5b22u32
	let data2: UInt16 = 0x6459u16
	let data3: UInt16 = 0x11d2u16
	let data41: UInt8 = 0x8eu8
	// TODO `0xbc_u8`
	let data42: UInt8 = 0x39u8
	let data43: UInt8 = 0x0u8
	let data44: UInt8 = 0xa0u8
	let data45: UInt8 = 0xc9u8
	let data46: UInt8 = 0x69u8
	let data47: UInt8 = 0x72u8
	let data48: UInt8 = 0x3bu8
	new () {}
}

@struct
class EFI_FILE_INFO_ID extends EFI_GUID {

	let data1: UInt32 = 0x9576e92u32
	let data2: UInt16 = 0x6d3fu16
	let data3: UInt16 = 0x11d2u16
	let data41: UInt8 = 0x8eu8
	// TODO `0xbc_u8`
	let data42: UInt8 = 0x39u8
	let data43: UInt8 = 0x0u8
	let data44: UInt8 = 0xa0u8
	let data45: UInt8 = 0xc9u8
	let data46: UInt8 = 0x69u8
	let data47: UInt8 = 0x72u8
	let data48: UInt8 = 0x3bu8
	new () {}

	// TODO allocate statically, not ARC
	let guid = new EFI_FILE_INFO_ID()
}

@struct declare class EFI_HANDLE {
	// Simply a pointer
}

// TODO validate sizeOf
@struct declare class EFI_TABLE_HEADER {
	let signature: UInt64
	let revision: UInt32
	let headerSize: UInt32
	let crc32: UInt32
	let reserved: UInt32
}

@struct declare class EFI_CONFIGURATION_TABLE {
	let vendorGuid: EFI_GUID
	let vendorTable: VoidPointer
}

@struct declare class SIMPLE_INPUT_INTERFACE {
	// Stub
}

@struct declare class SIMPLE_TEXT_OUTPUT_INTERFACE {
	// Stub
}

enum EFI_STATUS : UInt64 {
	// TODO `#define EFIERR(a) (0x8000000000000000 | a)`
	EFI_SUCCESS = 0
	EFI_NOT_READY = 9223372036854775814u64
	EFI_LOAD_ERROR = 9223372036854775809u64
	EFI_NOT_FOUND = 9223372036854775822u64
	EFI_OUT_OF_RESOURCES = 9223372036854775817u64
}

enum EFI_OpenMode : UInt64 {
	EFI_FILE_MODE_READ = 0x0000000000000001
	EFI_FILE_MODE_WRITE = 0x0000000000000002
	EFI_FILE_MODE_CREATE = 0x8000000000000000u64
}

@bitMask
enum EFI_FileAttribute : UInt64 {
	EFI_FILE_READ_ONLY = 0x0000000000000001
	EFI_FILE_HIDDEN = 0x0000000000000002
	EFI_FILE_SYSTEM = 0x0000000000000004
	EFI_FILE_RESERVED = 0x0000000000000008
	EFI_FILE_DIRECTORY = 0x0000000000000010
	EFI_FILE_ARCHIVE = 0x0000000000000020
	EFI_FILE_VALID_ATTR = 0x0000000000000037
}

// In C enums have signed int type
enum EFI_GRAPHICS_PIXEL_FORMAT : Int {
	PixelRedGreenBlueReserved8BitPerColor
	PixelBlueGreenRedReserved8BitPerColor
	PixelBitMask
	PixelBltOnly
	PixelFormatMax
}

enum EFI_LOCATE_SEARCH_TYPE : Int {
	AllHandles
	ByRegisterNotify
	ByProtocol
}

@struct declare class EFI_PIXEL_BITMASK {
	let redMask: UInt32
	let greenMask: UInt32
	let blueMask: UInt32
	let reservedMask: UInt32
}

@struct declare class EFI_GRAPHICS_OUTPUT_MODE_INFORMATION {
	let version: UInt32
	let horizontalResolution: UInt32
	let verticalResolution: UInt32
	let pixelFormat: EFI_GRAPHICS_PIXEL_FORMAT
	let pixelInformation: EFI_PIXEL_BITMASK
	let pixelsPerScanLine: UInt32
}

@struct declare class EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE {
	let maxMode: UInt32
	let mode: UInt32
	let info: EFI_GRAPHICS_OUTPUT_MODE_INFORMATION
	let sizeOfInfo: UINTN
	let frameBufferBase: EFI_PHYSICAL_ADDRESS
	let frameBufferSize: UINTN
}

@struct declare class EFI_GRAPHICS_OUTPUT_PROTOCOL {
	@noCapture let queryMode: () => EFI_STATUS
	@noCapture let setMode: (gop: EFI_GRAPHICS_OUTPUT_PROTOCOL, modeNumber: UInt32) => EFI_STATUS
	@noCapture let blt: () => EFI_STATUS
	@noCapture let mode: EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE
}

// TODO
//typedef UINT64 EFI_PHYSICAL_ADDRESS;
//typedef UINT64 EFI_VIRTUAL_ADDRESS;

/// Range requires a runtime mapping
let efi_memory_runtime = 0x8000000000000000u64

enum EFI_MEMORY_TYPE : Int {
	EfiReservedMemoryType
	EfiLoaderCode
	EfiLoaderData
	EfiBootServicesCode
	EfiBootServicesData
	EfiRuntimeServicesCode
	EfiRuntimeServicesData
	EfiConventionalMemory
	EfiUnusableMemory
	EfiACPIReclaimMemory
	EfiACPIMemoryNVS
	EfiMemoryMappedIO
	EfiMemoryMappedIOPortSpace
	EfiPalCode
	EfiMaxMemoryType
}

// TODO rename to TitleCase
@struct declare class EFI_MEMORY_DESCRIPTOR {
	/// Field size is 32 bits followed by 32 bit pad
	let type: EFI_MEMORY_TYPE
	/// Padding
	let pad: UInt32
	/// Field size is 64 bits
	let physicalStart: UInt64 // TODO EFI_PHYSICAL_ADDRESS
	/// Field size is 64 bits
	let virtualStart: UInt64 // TODO EFI_VIRTUAL_ADDRESS
	/// Field size is 64 bits
	let numberOfPages: UInt64
	/// Field size is 64 bits
	let attribute: UInt64
}

@struct declare class EFI_RUNTIME_SERVICES {
	@embed let hdr: EFI_TABLE_HEADER

	//
	// Time services
	//
	@noCapture let getTime: (time: EFI_TIME, capabilities: EFI_TIME_CAPABILITIES) => EFI_STATUS
	@noCapture let setTime: () => Void
	@noCapture let getWakeupTime: () => Void
	@noCapture let setWakeupTime: () => Void

	//
	// Virtual memory services
	//
	@noCapture let setVirtualAddressMap: () => Void
	@noCapture let convertPointer: () => Void

	//
	// Variable serviers
	//
	@noCapture let getVariable: () => Void
	@noCapture let getNextVariableName: () => Void
	@noCapture let setVariable: () => Void

	//
	// Misc
	//
	@noCapture let getNextHighMonotonicCount: () => Void
	@noCapture let resetSystem: () => Void

	@noCapture let updateCapsule: () => Void
	@noCapture let queryCapsuleCapabilities: () => Void
	@noCapture let queryVariableInfo: () => Void
}

@struct declare class EFI_TIME {
	var year: UInt16  // 1998 - 20XX
	var month: UInt8  // 1 - 12
	var day: UInt8	  // 1 - 31
	var hour: UInt8	  // 0 - 23
	var minute: UInt8 // 0 - 59
	var second: UInt8 // 0 - 59
	var pad1: UInt8
	var nanosecond: UInt32 // 0 - 999,999,999
	var timeZone: Int16	   // -1440 to 1440 or 2047
	var daylight: UInt8
	var pad2: UInt8
}

@struct declare class EFI_TIME_CAPABILITIES {
	let resolution: UInt32	// 1e-6 parts per million
	let accuracy: UInt32	// hertz
	let setsToZero: UInt8 // Set clears sub-second time
}

// Stubs can be filled later on demand
declare EFI_RAISE_TPL = ConstVoidPointer
declare EFI_RESTORE_TPL = ConstVoidPointer
declare EFI_FREE_PAGES = ConstVoidPointer
declare EFI_GET_MEMORY_MAP = ConstVoidPointer
declare EFI_ALLOCATE_POOL = ConstVoidPointer
declare EFI_FREE_POOL = ConstVoidPointer
declare EFI_CREATE_EVENT = ConstVoidPointer
declare EFI_SET_TIMER = ConstVoidPointer
declare EFI_WAIT_FOR_EVENT = ConstVoidPointer
declare EFI_SIGNAL_EVENT = ConstVoidPointer
declare EFI_CLOSE_EVENT = ConstVoidPointer
declare EFI_CHECK_EVENT = ConstVoidPointer

declare EFI_INSTALL_PROTOCOL_INTERFACE = ConstVoidPointer
declare EFI_REINSTALL_PROTOCOL_INTERFACE = ConstVoidPointer
declare EFI_UNINSTALL_PROTOCOL_INTERFACE = ConstVoidPointer
declare EFI_HANDLE_PROTOCOL = ConstVoidPointer
declare EFI_REGISTER_PROTOCOL_NOTIFY = ConstVoidPointer
declare EFI_LOCATE_HANDLE = ConstVoidPointer
declare EFI_LOCATE_DEVICE_PATH = ConstVoidPointer
declare EFI_INSTALL_CONFIGURATION_TABLE = ConstVoidPointer

declare EFI_IMAGE_LOAD = ConstVoidPointer
declare EFI_IMAGE_START = ConstVoidPointer
declare EFI_EXIT = ConstVoidPointer
declare EFI_IMAGE_UNLOAD = ConstVoidPointer
declare EFI_EXIT_BOOT_SERVICES = ConstVoidPointer
declare EFI_GET_NEXT_MONOTONIC_COUNT = ConstVoidPointer
declare EFI_STALL = ConstVoidPointer
declare EFI_CONNECT_CONTROLLER = ConstVoidPointer
declare EFI_DISCONNECT_CONTROLLER = ConstVoidPointer
declare EFI_OPEN_PROTOCOL = ConstVoidPointer
declare EFI_CLOSE_PROTOCOL = ConstVoidPointer
declare EFI_OPEN_PROTOCOL_INFORMATION = ConstVoidPointer
declare EFI_PROTOCOLS_PER_HANDLE = ConstVoidPointer
declare EFI_LOCATE_HANDLE_BUFFER = ConstVoidPointer
declare EFI_LOCATE_PROTOCOL = ConstVoidPointer
declare EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES = ConstVoidPointer
declare EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES = ConstVoidPointer
declare EFI_CALCULATE_CRC32 = ConstVoidPointer
declare EFI_COPY_MEM = ConstVoidPointer
declare EFI_SET_MEM = ConstVoidPointer
declare EFI_CREATE_EVENT_EX = ConstVoidPointer
// TODO all to @noCapture => stubs

enum EFI_ALLOCATE_TYPE : Int {
	AllocateAnyPages
	AllocateMaxAddress
	AllocateAddress
	MaxAllocateType
}

@struct declare class EFI_BOOT_SERVICES {
	@embed let hdr: EFI_TABLE_HEADER

	//
	// Task priority functions
	//
	let raiseTPL: EFI_RAISE_TPL
	let restoreTPL: EFI_RESTORE_TPL

	//
	// Memory functions
	//
	@noCapture let allocatePages: (
		type: EFI_ALLOCATE_TYPE,
		memoryType: EFI_MEMORY_TYPE,
		noPages: UINTN,
		memory: Pointer<EFI_PHYSICAL_ADDRESS>
	) => EFI_STATUS

	let freePages: EFI_FREE_PAGES

	@noCapture let getMemoryMap: (
		memoryMapSize: Pointer<UINTN>,
		memoryMap: EFI_MEMORY_DESCRIPTOR,
		mapKey: Pointer<UINTN>,
		descriptorSize: Pointer<UINTN>,
		descriptorVersion: Pointer<UInt32>
	) => EFI_STATUS

	let allocatePool: EFI_ALLOCATE_POOL
	let freePool: EFI_FREE_POOL

	//
	// Event & timer functions
	//
	let createEvent: EFI_CREATE_EVENT
	let setTimer: EFI_SET_TIMER
	let waitForEvent: EFI_WAIT_FOR_EVENT
	let signalEvent: EFI_SIGNAL_EVENT
	let closeEvent: EFI_CLOSE_EVENT
	let checkEvent: EFI_CHECK_EVENT

	//
	// Protocol handler functions
	//
	let installProtocolInterface: EFI_INSTALL_PROTOCOL_INTERFACE
	let reinstallProtocolInterface: EFI_REINSTALL_PROTOCOL_INTERFACE
	let uninstallProtocolInterface: EFI_UNINSTALL_PROTOCOL_INTERFACE
	@noCapture let handleProtocol: (
		handle: EFI_HANDLE,
		protocol: EFI_GUID,
		interfaceStorage: Pointer<Pointer<Void>>
	) => EFI_STATUS
	let pCHandleProtocol: EFI_HANDLE_PROTOCOL
	let registerProtocolNotify: EFI_REGISTER_PROTOCOL_NOTIFY
	let locateHandle: EFI_LOCATE_HANDLE
	let locateDevicePath: EFI_LOCATE_DEVICE_PATH
	let installConfigurationTable: EFI_INSTALL_CONFIGURATION_TABLE

	//
	// Image functions
	//
	let loadImage: EFI_IMAGE_LOAD
	let startImage: EFI_IMAGE_START
	let exit: EFI_EXIT
	let unloadImage: EFI_IMAGE_UNLOAD

	@noCapture let exitBootServices: (
		imageHandle: EFI_HANDLE,
		mapKey: UINTN
	) => EFI_STATUS

	//
	// Misc functions
	//
	let getNextMonotonicCount: EFI_GET_NEXT_MONOTONIC_COUNT
	let stall: EFI_STALL

	@noCapture let setWatchdogTimer: (
		timeout: UINTN,
		watchdogCode: UInt64,
		dataSize: UINTN,
		watchdogData: ConstWideCharPointer
	) => Void

	//
	// DriverSupport Services
	//
	let connectController: EFI_CONNECT_CONTROLLER
	let disconnectController: EFI_DISCONNECT_CONTROLLER

	//
	// Open and Close Protocol Services
	//
	let openProtocol: EFI_OPEN_PROTOCOL
	let closeProtocol: EFI_CLOSE_PROTOCOL
	let openProtocolInformation: EFI_OPEN_PROTOCOL_INFORMATION

	//
	// Library Services
	//
	let protocolsPerHandle: EFI_PROTOCOLS_PER_HANDLE
	@noCapture let locateHandleBuffer: (
		searchType: EFI_LOCATE_SEARCH_TYPE,
		protocol: EFI_GUID,
		searchKey: Pointer<Void>,
		noHandles: Pointer<UINTN>,
		buffer: Pointer<EFI_HANDLE>
	) => EFI_STATUS

	@noCapture let locateProtocol: (
		protocol: EFI_GUID,
		registration: Pointer<Void>,
		interfaceStorage: Pointer<Pointer<Void>>
	) => EFI_STATUS

	let installMultipleProtocolInterfaces: EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES
	let uninstallMultipleProtocolInterfaces: EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES

	//
	// 32-bit CRC Services
	//
	let calculateCrc32: EFI_CALCULATE_CRC32

	//
	// Misc Services
	//
	let copyMem: EFI_COPY_MEM
	let setMem: EFI_SET_MEM
	let createEventEx: EFI_CREATE_EVENT_EX
}

@struct declare class EFI_SYSTEM_TABLE {
	@embed let hdr: EFI_TABLE_HEADER
	let firmwareVendor: ConstWideCharPointer
	let firmwareRevision: UInt32

	let consoleInHandle: EFI_HANDLE
	let conIn: SIMPLE_INPUT_INTERFACE

	let consoleOutHandle: EFI_HANDLE
	let conOut: SIMPLE_TEXT_OUTPUT_INTERFACE

	let standardErrorHandle: EFI_HANDLE
	let stdErr: SIMPLE_TEXT_OUTPUT_INTERFACE

	let runtimeServices: EFI_RUNTIME_SERVICES
	let bootServices: EFI_BOOT_SERVICES

	let numberOfTableEntries: UINTN
	let configurationTable: ArrayOfStructPointer<EFI_CONFIGURATION_TABLE>
}

@struct declare class EFI_FILE_INFO {
	let size: UInt64
	let fileSize: UInt64
	let physicalSize: UInt64
	let createTime: EFI_TIME
	let lastAccessTime: EFI_TIME
	let modificationTime: EFI_TIME
	let attribute: UInt64
	let fileName: ArrayByValue<WideChar, 2048>
	// Note: this name storage should be dynamically allocated
	// but here it is just large enough for any file system
	new ()
	// TODO
	// Because of `declare` assumes that fields
	// are filled in external constructor?
}

@struct declare class EFI_SIMPLE_FILE_SYSTEM_PROTOCOL {
	let revision: UInt64
	@noCapture let openVolume: (
		fs: EFI_SIMPLE_FILE_SYSTEM_PROTOCOL,
		root: Pointer<EFI_FILE_PROTOCOL>
	) => EFI_STATUS
}

// Same as `EFI_FILE_HANDLE` and `EFI_FILE`
@struct declare class EFI_FILE_PROTOCOL {
	let revision: UInt64

	@noCapture let open: (
		file: EFI_FILE_PROTOCOL,
		newHandle: Pointer<EFI_FILE_PROTOCOL>,
		fileName: ConstWideCharPointer,
		openMode: EFI_OpenMode
		attributes: EFI_FileAttribute
	) => EFI_STATUS

	@noCapture let close: (
	) => EFI_STATUS

	@noCapture let delete: (
	) => EFI_STATUS

	@noCapture let read: (
	) => EFI_STATUS

	@noCapture let write: (
	) => EFI_STATUS

	@noCapture let getPosition: (
	) => EFI_STATUS

	@noCapture let setPosition: (
	) => EFI_STATUS

	@noCapture let getInfo: (
	) => EFI_STATUS

	@noCapture let setInfo: (
	) => EFI_STATUS

	@noCapture let flush: (
	) => EFI_STATUS

	@noCapture let openEx: (
	) => EFI_STATUS

	@noCapture let readEx: (
	) => EFI_STATUS

	@noCapture let writeEx: (
	) => EFI_STATUS

	@noCapture let flushEx: (
	) => EFI_STATUS
}

//@size(8 + 8 + 4 + 8 * 9 + 4 + EFI_HANDLE * 10)
//@struct class INT32 {
//
//}
//
//class INTN {}
//class UINTN {}
