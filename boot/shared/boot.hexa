// The Tofita Kernel
// Copyright (C) 2020  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Constants

// Start of kernel sections in memory
let KernelVirtualBase = (uint64_t)0xffff800000000000
let FramebufferStart = (KernelVirtualBase + 768 * 1024 * 1024)
// TODO: no need for mapping FramebufferStart if WholePhysicalStart used
// TODO proper dynamically computed numbers

// Mapping of 1:1 of physical memory as virtual = physical + WholePhysicalStart
// Note: Mapping is done on-demand per-page for faster loading
let WholePhysicalStart = (FramebufferStart + 128 * 1024 * 1024)
let PAGE_SIZE = 4096 // 4 KiB

// Helpers

@extern "C++" template <typename T> @struct
class Physical {
	var physical: UInt64

	static Physical<T> toPhysical(physical: UInt64) {
		return (Physical<T>)physical
	}

	T *toVirtual() {
		var result: UInt64 = (WholePhysicalStart as! UInt64) + physical
		return (T *)result
	}

	T *toVirtualOffset(offset: UInt64) {
		var result: UInt64 = (WholePhysicalStart as! UInt64) + physical + offset
		return (T *)result
	}
}

_Static_assert(sizeof(Physical<char8_t>) == sizeof(uint64_t), "physical address has to have 64 bits")

// Data transferred from UEFI application into kernel loader

@struct
class EfiMemoryMap {
	efi.EFI_MEMORY_DESCRIPTOR *memoryMap
	var memoryMapSize: UInt64
	var mapKey: UInt64
	var descriptorSize: UInt64
	var descriptorVersion: UInt32
}

@struct
class Framebuffer {
	var base: UInt64 // virtual address
	var physical: UInt64 // physical address
	var size: UInt32 // in bytes
	var width: UInt32
	var height: UInt32
	var pixelsPerScanLine: UInt32
}

@struct
class RamDisk {
	var base: UInt64 // virtual address
	var physical: UInt64 // physical address
	var size: UInt32 // in bytes
}

@struct
class KernelParams {
	var pml4: UInt64
	var stack: UInt64
	var physicalBuffer: UInt64 // physical address of where kernel loader placed
	var physicalBytes: UInt64
	var physicalRamBitMaskVirtual: UInt64 // virtual address of where RAM usage
										// bit-map stored
	var imageHandle: efi.EFI_HANDLE
	var efiMemoryMap: EfiMemoryMap
	efi.EFI_RUNTIME_SERVICES *efiRuntimeServices = null
	var framebuffer: Framebuffer
	var ramdisk: RamDisk
	var acpiTablePhysical: UInt64
	var ramBytes: UInt64

	var time: efi.EFI_TIME
	var capabilities: efi.EFI_TIME_CAPABILITIES
	// UInt8 isLiveBootWithInstaller; == 1 == 0, don't show logon screen (and
	// don't allow to login! in the sense that it looks like a security hole
	// like "let it in without entering a login-password")
}

typedef fun(__fastcall *InitKernel)(const KernelParams *)
// TODO ^ fix that in quake
typedef fun(__fastcall *InitKernelTrampoline)(UInt64 kernelParams, pml4: UInt64, stack: UInt64,
												   UInt64 entry)
