// The Tofita Kernel
// Copyright (C) 2022 Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.


fun memzero(dest: VoidPointer, len: UInt64) {
	memset(dest, 0, len)
}

@keep
@rename('___chkstk_ms')
fun chkstkStub(): Void {}
// STB library
#define STBI_NO_SIMD
#define STBI_NO_STDIO
#define STB_IMAGE_IMPLEMENTATION
#define STBI_ONLY_PNG
import "formats/stb_image/libc.cpp"
import "formats/stb_image/stb_image.hpp"
import "formats/stb_image/unlibc.cpp"
import "formats/exe/exe.cpp"
import "formats/cur/cur.cpp"
import "formats/ico/ico.cpp"
import "formats/bmp/bmp.cpp"
import "formats/lnk/lnk.cpp"
import "gui/blur.cpp"
import "gui/desktop.cpp"
import "gui/quake.cpp"
import "gui/text.cpp"
import "gui/windows.cpp"
import "gui/compositor.cpp"
import "gui/dwm.cpp"
import "syscalls/user32/userCall.cpp"

const KernelParams *paramsCache = null
var startupMilliseconds: UInt64 = 0

fun kernelInit(params: KernelParams) {
	serialPrintln("<Tofita> Greentea OS " + versionName + " " + versionMajor + "." + versionMinor + " " + versionTag + " kernel loaded and operational")
	serialPrintf("<Tofita> CR3 points to: %8\n", params.pml4 as! UInt64)
	paramsCache = params
	// PhysicalAllocator.init(Pointer.of(params.efiMemoryMap), params.physicalRamBitMaskVirtual,
	// DOWN_BYTES_TO_PAGES(params.ramBytes))
	PhysicalAllocator.init(params)
	pages.pml4entries = (pages.PageEntry *)((wholePhysicalStart as! UInt64) + (uint64_t)(params.pml4))

	if false {
		serialPrintf("<> %8 == %8\n", (uint64_t)(4096 * 10),
					 pages.resolveAddr(pages.pml4entries, 4096 * 20))
		serialPrintf("<> %8 == %8\n", (uint64_t)(4096 * 10 + 123),
					 pages.resolveAddr(pages.pml4entries, 4096 * 20 + 123))
		serialPrintf("<> %8 == %8\n", (uint64_t)(0),
					 pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64)))
		serialPrintf("<> %8 == %8\n", (uint64_t)(0 + 123),
					 pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64) + 123))
		serialPrintf("<> %8 == %8\n", (uint64_t)(0 + 4096),
					 pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64) + 4096))
		mapMemory(pml4entries, 4096, 4096, 256)
		mapMemory(pml4entries, 4096, 4096, 256)
		mapMemory(pml4entries, 4096 * 20u64, 4096 * 10u64, 256)

		serialPrintf(
			"<> %8 == %8\n", (uint64_t)(0 + 4096 * 1000 + 123),
			pages.resolveAddr(pages.pml4entries, (wholePhysicalStart as! UInt64) + 4096 * 1000 + 123))
		serialPrintf("<> %8 == %8\n", (uint64_t)(1048576),
					 pages.resolveAddr(pages.pml4entries, (uint64_t)0xffff800000000000))
		serialPrintf("<> %8 == %8\n", (uint64_t)(1048576 + 123),
					 pages.resolveAddr(pages.pml4entries, 0xffff800000000000u64 + 123))

		// serialPrint("resolves from, to, wh, wh+8888: ")
		// serialPrint("\n")
		// serialPrintHex(4096 * 10)
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr(4096 * 20 + 123))
		// serialPrint("==\n")
		// serialPrintHex(pages.resolveAddr(4096 * 20))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((wholePhysicalStart as! UInt64)))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((wholePhysicalStart as! UInt64) + 8888))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr((wholePhysicalStart as! UInt64) + 4096 * 1000))
		// serialPrint("\n")
		// serialPrintHex(pages.resolveAddr(0xffff800000000000))
		// serialPrint("\n")
	}

	setFramebuffer(params.framebuffer)
	setRamDisk(params.ramdisk)

	if (sizeof(UInt8 *) == 4)
		serialPrintln("<Tofita> void*: 4 bytes")
	if (sizeof(UInt8 *) == 8)
	}
		serialPrintln("<Tofita> void*: 8 bytes")
	}

	disablePic()
	enableInterrupts()
	enablePS2Mouse()

	initText()
	initializeCompositor()

	quakePrintf("Greentea OS " + versionName + " " + versionMajor + "." + versionMinor + " " + versionTag + " loaded and operational\n")

	// TODO enableLocalApic()

	var cpuid: CPUID = getCPUID()

	var megs: UInt32 = Math.round((double)params.ramBytes / (1024.0 * 1024.0))
	quakePrintf("[CPU] %s %s %d MB RAM\n", cpuid.vendorID, cpuid.brandName, megs)

	if !ACPIParser.parse(params.acpiTablePhysical) {
		quakePrintf("ACPI is *not* loaded\n")
	} else {
		quakePrintf("ACPI 2.0 is loaded and ready\n")
	}

	quakePrintf("Enter 'help' for commands\n")

	{
		// TODO move to compositor
		var a: RamDiskAsset = getRamDiskAsset("root/Windows/Web/Wallpaper/Tofita/default.bmp")
		var bmp: Pointer<Bitmap32> = bmp.loadBmp24(&a)
		setWallpaper(bmp, Center)
	}

	// TODO var sandbox = sandbox.createSandbox()
	initDwm()

	// Setup scheduling
	currentThread = ThreadKind.THREAD_INIT

	// GUI thread
	{
		memset(Pointer.of(guiThreadFrame), 0, sizeof(InterruptFrame)) // Zeroing
		memset(Pointer.of(guiStack), 0, sizeof(stackSizeForKernelThread)) // Zeroing

		guiThreadFrame.ip = (uint64_t)Pointer.of(guiThreadStart)
		guiThreadFrame.cs = Selector.SYS_CODE64_SEL
		// TODO allocate as physicall memory
		guiThreadFrame.sp = (uint64_t)Pointer.of(guiStack) + stackSizeForKernelThread
		guiThreadFrame.ss = Selector.SYS_DATA32_SEL
	}

	// Main thread
	{
		memset(Pointer.of(kernelThreadFrame), 0, sizeof(InterruptFrame)) // Zeroing
		memset(Pointer.of(kernelStack), 0, sizeof(stackSizeForKernelThread)) // Zeroing

		kernelThreadFrame.ip = (uint64_t)Pointer.of(kernelThreadStart)
		kernelThreadFrame.sp = (uint64_t)Pointer.of(kernelStack) + stackSizeForKernelThread
		kernelThreadFrame.cs = Selector.SYS_CODE64_SEL
		kernelThreadFrame.ss = Selector.SYS_DATA32_SEL
	}

	// Idle process
	{
		memset(Pointer.of(process.processes), 0, sizeof(process.processes)) // Zeroing
		var idle: Process = processes[0]
		idle.pml4 = pml4entries // Save CR3 template to idle process
		idle.schedulable = true // At idle schedule to idle process
		idle.present = true
		idle.syscallToHandle = TofitaSyscalls.Noop
		currentProcess = 0
		pml4kernelThread = processes[0].pml4
	}

	// Demo
	if false {
		for i in 3 {
			var demo: Process = processCreate()
			serialPrintf("<> pid == %u\n", demo.pid)
			processInit(demo)
			loadExeIntoProcess("desktop/wndapp.exe", demo)
			demo.schedulable = true
		}
	}

						  paramsCache.time.Second * 1000
	startupMilliseconds = paramsCache.time.hour * 60 * 60 * 1000 + paramsCache.time.minute * 60 * 1000 +

	// Show something before scheduling delay
	composite(startupMilliseconds)
	copyToScreen()
	serialPrintln("<Tofita> [ready for scheduling]")
}

fun switchToUserProcess() {
	// if (processesCount == 0)
	//	amd64.enableAllInterruptsAndHalt()
	// TODO
	var next = getNextProcess()

	if next == 0 {
		markAllProcessessSchedulable()
		next = getNextProcess()
	}

	if next == 0 {
		// serialPrintln("<Tofita> [halt]")
		// amd64.enableAllInterruptsAndHalt() // Nothing to do
	}
	// else
	yield()
	// TODO
}

fun kernelThread() {
	serialPrintln("<Tofita> [kernelThread] thread started")

	// TODO move to preTest with infinite loop on fail
	serialPrintf("<seh> 1 == %u\n", probeForReadOkay((uint64_t)Pointer.of(currentThread), 1))
	serialPrintf("<seh> 1 == %u\n", probeForReadOkay((uint64_t)Pointer.of(guiStack), 1))
	serialPrintf("<seh> 0 == %u\n", probeForReadOkay((uint64_t)-1, 1))
	serialPrintf("<seh> 1 == %u\n", probeForReadOkay((uint64_t)Pointer.of(switchToNextProcess), 1))
	serialPrintf("<seh> 0 == %u\n", probeForReadOkay(321, 1))
	serialPrintf("<seh> 0 == %u\n", probeForReadOkay(999999999, 1))

	while true {
		@volatile var index: UInt64 = 1 // Idle process ignored
		while index < 255 {		 // TODO
			@volatile var process = processes[index]
			if process.present == true {
				if process.syscallToHandle != TofitaSyscalls.Noop {
					@volatile let syscall = process.syscallToHandle
					process.syscallToHandle = TofitaSyscalls.Noop
					@volatile var frame = process.frame

					// Select pml4 to work within current process memory
					// Remember pml4 for proper restore from scheduling
					pml4kernelThread = process.pml4
					writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))

					// TODO refactor to separate syscall handler per-DLL

					if syscall == TofitaSyscalls.DebugLog {
						serialPrintf("[[DebugLog:PID %d]] ", index)
						serialPrintf("[[rcx=%u rdx=%u r8=%u]] ", frame.rcxArg0, frame.rdxArg1, frame.r8)

							var payload: Pointer<DebugLogPayload> = (DebugLogPayload *)frame.rdxArg1
						if probeForReadOkay(frame.rdxArg1, sizeof(DebugLogPayload)) {
							// Note this is still very unsafe
							if probeForReadOkay((payload.message as! UInt64), 1) {
								serialPrintf(payload.message, payload.extra, payload.more)
							}
						}

						serialPrintf("\n")
						process.schedulable = true
					} else if syscall == TofitaSyscalls.ExitProcess {
						serialPrintf("[[ExitProcess:PID %d]] %d\n", index, frame.rdxArg1)
						process.present = false

						// Select pml4 of idle process for safety
						pml4kernelThread = processes[0].pml4
						writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))

						// Deallocate process
						processDestroy(process)
					} else if syscall == TofitaSyscalls.Cpu {
						serialPrintf("[[Cpu:PID %d]] %d\n", index, frame.rdxArg1)
						quakePrintf("Process #%d closed due to CPU exception #%u\n", index, frame.index)
						process.present = false

						// Page fault
						if frame.index == 0x0E {
							quakePrintf("#PF at %8\n", process.cr2PageFaultAddress)
						}
						if frame.index == 0x0D {
							quakePrintf("#GPF at %8\n", frame.ip)
						}
						if frame.index == 0x03 {
							quakePrintf("#BP at %8\n", frame.ip)
						}

						// Select pml4 of idle process for safety
						pml4kernelThread = processes[0].pml4
						writeCr3((pml4kernelThread as! UInt64) - (wholePhysicalStart as! UInt64))

						// Deallocate process
						processDestroy(process)
					} else {
						frame.raxReturn = 0 // Must return at least something
						// Note ^ some code in syscall handlers may *read* this value
						// So set it to zero just in case

						if !userCallHandled(process, syscall) {
							// Unknown syscall is no-op
							serialPrintf("[[PID %d]] Unknown or unhandled syscall %d\n", index,
										 frame.rcxArg0)
							frame.raxReturn = 0
							process.schedulable = true
						}
					}
				}
			}
			index++
		}

		switchToUserProcess()
	}
}

declare fun guiThreadStart(): Void

// In case of kernel crash set instruction pointer to here
fun kernelThreadLoop() {
	serialPrintln("<Tofita> [looping forever]")
	while true {
		amd64.pause()
	}
}
declare fun kernelThreadStart(): Void

fun guiThread() {
	serialPrintln("<Tofita> [guiThread] thread started")

	while true {
		// Poll PS/2 devices
		pollPS2Devices()

		if haveToRender == false {
			switchToUserProcess()
		}

		haveToRender = false

		composite(startupMilliseconds)
		copyToScreen()

		switchToUserProcess()
	}
}

fun kernelMain(params: ConstPointer<KernelParams>) {
declare fun __sync_synchronize(): Void

	kernelInit(params)
	__sync_synchronize()

	// TODO composite here first frame!!!
	// cause if crashes on hardware, at least it shows something

	// sti . start sheduling here
	// It will erase whole stack on next sheduling
	// TODO kernel `yield`/`await`
	while true {
		enableAllInterruptsAndHalt()
	}
	// TODO hexa: error if code present in unreachable block
	// (no break/continue/throw)
}
