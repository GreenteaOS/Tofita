// The Tofita Kernel
// Copyright (C) 2020  Oleg Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#define USER32_DLL @dllExport
import "user32.hpp"
import "user32Vars.hpp"
import "../kernel32.dll/kernel32.hpp"

// Utils

user32.Window *handleToWindow(hWnd: wapi.HWnd) {
	if (hWnd == null)
		return null // TODO return desktop
	if (hWnd == INVALID_HANDLE_VALUE)
		return null
	if (((user32.Window *)hWnd).windowIsWindow != user32.windowIsWindow)
		return null
	return (user32.Window *)hWnd
}

wapi.HWnd windowToHandle(user32.Window *window) {
	// TODO offset ptr 8-byte aligned + reserved space
	// os it fits into upper half of virtual space
	return (wapi.HWnd)window
}

// WAPI
@extern "C" {

wapi.Atom RegisterClassW(const wapi.WindowClass *wc) {
	tofitaDebugLog("RegisterClassW called")

	// TODO use libc func utf16le
	var len = 0
	// TODO lpszClassName takes atoms?
	var str = (const UInt16 *)wc.lpszClassName
	for (UInt16 i = 0; i < 256; ++i) {
		// Increment upfront to rezerve for zeros
		len += 2
		// Null-termination of utf16le is \0\0
		if (str[i] == 0)
			break
	}

	var tail = &user32.rootClass
	while (tail.next != null)
		tail = tail.next

	var list = (user32.ClassesLinkedList *)LocalAlloc(0, sizeof(user32.ClassesLinkedList))
	var name = (UInt16 *)LocalAlloc(0, len)
	list.next = null

	for (UInt16 i = 0; i < len; ++i) {
		name[i] = str[i]
	}

	list.name = name
	list.wc = *wc

	tail.next = list
	tail = tail.next

	tofitaDebugLog("RegisterClassW done")
	return (wapi.Atom)0
}

wapi.HWnd CreateWindowExW(UInt32 dwExStyle, const WideChar *lpClassName, const WideChar *lpWindowName,
						   UInt32 dwStyle, x: Int32, y: Int32, nWidth: Int32, nHeight: Int32,
						   wapi.HWnd hWndParent, wapi.HMenu hMenu, wapi.HInstance hInstance,
						   Void *lpParam) {
	tofitaDebugLog("CreateWindowExW called")

	// Find class
	var *list = &user32.rootClass
	var name = lpClassName
	var found = false
	const wapi.WindowClass *wc = null

	while (list.next != null) {
		// Step upfront, to ignore empty root
		list = list.next

		var i: UInt16 = 0
		while (true) {
			if ((list.name[i] == name[i]) && (name[i] == 0)) {
				tofitaDebugLog("CreateWindowExW found class {%S}\n", (uint64_t)name)
				found = true
				wc = &list.wc
				break
			}
			if (list.name[i] == name[i]) {
				i++
				continue
			}
			break
		}
	}

	if (!found) {
		tofitaDebugLog("CreateWindowExW not found return")
		return (wapi.HWnd) null
	}

	// Prepare for syscall
	var payload: CreateWindowExPayload

	payload.wc = wc

	payload.lpClassName = lpClassName
	payload.lpWindowName = lpWindowName
	payload.dwStyle = dwStyle
	payload.x = x
	payload.y = y
	payload.nWidth = nWidth
	payload.nHeight = nHeight
	payload.hWndParent = hWndParent
	payload.hMenu = hMenu
	payload.hInstance = hInstance
	payload.lpParam = lpParam

	// Create local window counterpart
	var window = (user32.Window *)LocalAlloc(0, sizeof(user32.Window))

	let hWnd = (wapi.HWnd)window
	payload.hWnd = hWnd

	// Create native window counterpart
	var windowId: UInt64 = tofitaCreateWindowEx(&payload)

	window.windowId = windowId
	window.windowIsWindow = user32.windowIsWindow
	window.proc = wc.lpfnWndProc

	// Initial paint
	// TODO should be called somewhere else, in syscall of windows creation?
	PostMessage(hWnd, wapi.Message.WM_PAINT, null, null)

	tofitaDebugLog("CreateWindowExW done")
	return hWnd
}

wapi.Bool ShowWindow(wapi.HWnd hWnd, nCmdShow: Int32) {
	tofitaDebugLog("ShowWindow called")
	var window = handleToWindow(hWnd)
	var result: wapi.Bool = 0
	if (window != null) {
		switch (nCmdShow) {
		case SW_HIDE: {
			tofitaShowWindow(window.windowId, nCmdShow)
			result = 1
			break
		}
		case SW_SHOW:
		case SW_SHOWNORMAL:
		case SW_SHOWDEFAULT: {
			tofitaShowWindow(window.windowId, nCmdShow)
			result = 1
			break
		}
		default: {
			// TODO
		}
		}
	}
	tofitaDebugLog("ShowWindow done")
	return result
}

// TODO take 2 or more messages at a time for better perf (this is pretty common)
wapi.Bool GetMessageW(wapi.Msg *msg, wapi.HWnd hWnd, wMsgFilterMin: UInt32, wMsgFilterMax: UInt32) {
	tofitaDebugLog("GetMessageW called")
	var result: wapi.Bool = 1

	var payload: GetMessagePayload
	payload.msg = msg
	payload.hWnd = hWnd
	payload.wMsgFilterMin = wMsgFilterMin
	payload.wMsgFilterMax = wMsgFilterMax
	tofitaGetMessage(&payload)

	// Stop iteration
	if (msg.message == wapi.Message.WM_QUIT)
		result = 0

	tofitaDebugLog("GetMessageW done")
	return result
}

wapi.Bool TranslateMessage(wapi.Msg *msg) {
	tofitaDebugLog("TranslateMessage called")
	// TODO
	tofitaDebugLog("TranslateMessage done")
	return 0
}

wapi.LResult DispatchMessageW(wapi.Msg *msg) {
	tofitaDebugLog("DispatchMessageW called")
	var result: wapi.LResult = 0
	if (msg.hwnd != null) {
		var window = handleToWindow(msg.hwnd)
		if (window == null)
			return 0
		// ERROR_INVALID_HANDLE
		if (msg.message == wapi.Message.WM_PAINT) {
			result = window.proc(msg.hwnd, msg.message, msg.wParam, msg.lParam)
		} else {
			result = window.proc(msg.hwnd, msg.message, msg.wParam, msg.lParam)
		}
		// result = ERROR_SUCCESS
	} else {
		// TODO
	}
	tofitaDebugLog("DispatchMessageW done")
	return result
}

wapi.Bool PostMessage(wapi.HWnd hWnd, wapi.Message msg, Void *wParam, Void *lParam) {
	var payload: PostMessagePayload
	payload.hWnd = hWnd
	payload.msg = msg
	payload.wParam = wParam
	payload.lParam = lParam
	return tofitaPostMessage(&payload)
}

Void PostQuitMessage(nExitCode: Int32) {
	tofitaDebugLog("PostQuitMessage called")
	PostMessage(null, wapi.Message.WM_QUIT, (Void *)nExitCode, null)
	tofitaDebugLog("PostQuitMessage done")
	// TODO ERROR_SUCCESS
}

wapi.HDc BeginPaint(wapi.HWnd hWnd, wapi.PaintStruct *ps) {
	tofitaDebugLog("BeginPaint called")
	var window = handleToWindow(hWnd)
	if (window == null)
		return null
	// We do this every time, cause window may be resized
	njraaGetOrCreateWindowFramebuffer(window.windowId, &window.fb)
	ps.rcPaint.left = 0
	ps.rcPaint.top = 0
	ps.rcPaint.right = window.fb.width
	ps.rcPaint.bottom = window.fb.height
	tofitaDebugLog("BeginPaint done")
	return (wapi.HDc)&window.fb // TODO
}

Void @fastcall setPixel(nj.WindowFramebuffer *fb, x: Int16, y: Int16, nj.Pixel32 pixel) {
	if ((x < 0) || (y < 0))
		return
	if ((x > fb.width - 1) || (y > fb.height - 1))
		return
	fb.pixels[y * fb.width + x] = pixel
}

Int32 FillRect(wapi.HDc dc, const wapi.Rect *lprc, wapi.HBrush brush) {
	tofitaDebugLog("FillRect called")

	var fb = (nj.WindowFramebuffer *)dc

	var color: nj.Pixel32
	color.color = 0xFFAA0000

	for (Int16 y = lprc.top; y < lprc.bottom; y++) {
		for (Int16 x = lprc.left; x < lprc.right; x++) {
			setPixel(fb, x, y, color)
		}
	}

	tofitaDebugLog("FillRect done")
	return 1
}

wapi.Bool EndPaint(wapi.HWnd hWnd, wapi.PaintStruct *ps) {
	tofitaDebugLog("EndPaint called")
	var window = handleToWindow(hWnd)
	if (window == null)
		return 0
	njraaSwapWindowFramebuffer(window.windowId, &window.fb)
	tofitaDebugLog("EndPaint done")
	return 1
}

wapi.LResult DefWindowProcW(wapi.HWnd hWnd, wapi.Message uMsg, Void *wParam, Void *lParam) {
	tofitaDebugLog("DefWindowProcW called")
	var window = handleToWindow(hWnd)
	if (window == null)
		return 0
	if (uMsg == wapi.Message.WM_CLOSE) {
		// TODO DestroyWindow(hWnd)
		// TODO probably should be async post?
		window.proc(hWnd, wapi.Message.WM_DESTROY, 0, 0)
		window.proc(hWnd, wapi.Message.WM_NCDESTROY, 0, 0)
		return 0
	}
	tofitaDebugLog("DefWindowProcW done")
	return 0
}
}

@extern "C" @fastcall Void _DllMainCRTStartup() {
	user32.rootClass.next = null
}
