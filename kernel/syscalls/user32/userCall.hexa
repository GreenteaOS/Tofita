// The Tofita Kernel
// Copyright (C) 2022-2023 Oleh Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

fun userCallHandled(@volatile process: TofitaProcess, syscall: TofitaSyscalls) Bool {
	@volatile var frame = process.frame

	if syscall == TofitaSyscalls.CreateWindowEx {
		if !probeForReadOkay(frame.rdxArg1, sizeOf<CreateWindowExPayload>()) {
			return false
		}

		var payload = frame.rdxArg1 as! CreateWindowExPayload

		// TODO why 16?
		if probeForReadOkay((payload.lpClassName as! UInt64), 16) {
			serialPrintf("<> lpClassName == %S\n", payload.lpClassName)
		}

		if probeForReadOkay((payload.lpWindowName as! UInt64), 16) {
			serialPrintf("<> lpWindowName == %S\n", payload.lpWindowName)
		}

		var window = overlappedWindow_create(process.pid)

		// TODO ensure this opaque value, and not an accessible pointer
		window.hWnd = payload.hWnd as! Handle

		// TODO proper probe method, probably separate probeForWideCharOkay
		// ^ probably should produce `String?` and separate `probeForCopyOkay`
		if probeForReadOkay((payload.lpWindowName as! UInt64), 8) {
			// TODO must error `candidate function not viable: no known conversion from 'const wchar_t *' to 'const uint16_t      *'` window.title = String.fromUTF16z(payload.lpWindowName)
			// TODO should limit the max string length and be SEH-safe
			// ^ maybe sehCountNonNull16bits(), oh no no no
			// this way may go out of think if virtual memory changes
			// instead String.consumeUTF16z that doesn't create a copy
			// no no no no no! just copy into global (TLS) char16[MAX_PATH]
			// and copy string from there! yeah! sehStringFromUTF16z(addr, limit: MAX_PATH - 1?)
			window.title = String.fromUTF16z(payload.lpWindowName as! ConstArrayPointer<UInt16>)
			// TODO ^ limit to lower address space, to not capable of reading kernel mem
			// TODO another idea of temporal mapping to zero page?
			// ^ this way values would be zero anyway so can be easily tested with guard
		} else {
			// TODO use app name here
			window.title = "undefined"
		}

		frame.raxReturn = window.windowId
		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.ShowWindow {
		// TODO merge to probeForReadAndConvert os it takes <T> and returns nullable for `if let`
		if !probeForReadOkay(frame.rdxArg1, sizeOf<ShowWindowPayload>()) {
			return false
		}

		let payload = frame.rdxArg1 as! ShowWindowPayload

		let windowId: UInt64 = payload.windowId
		let nCmdShow = payload.nCmdShow
		var window = overlappedWindow_find(process.pid, windowId)

		if window != null {
			window.visible = true
			overlappedWindow_attach(windowId)
		}

		process.schedulable = true
		return true
	}

	// TODO to exhaustive switch over selected syscall enum subset
	// ^ just multi-inherit multiple enums
	if syscall == TofitaSyscalls.GetMessage {
		// TODO pointers should be validated to be not within kernel space!
		if !probeForWriteOkay(frame.rdxArg1, sizeOf<GetMessagePayload>()) {
			// TODO wrote here %S instead of %8 and it crashed, must think about such safety
			// serialPrintf("<> GetMessage frame.rdxArg1 probe fail %8\n", frame.rdxArg1)
			return false
		}

		let payload = frame.rdxArg1 as! GetMessagePayload

		frame.raxReturn = getMessage(process, payload).toZeroOrOne

		// Should sorts of loop forever
		if frame.raxReturn != 0 {
			process.schedulable = true
		} else {
			// process.syscallToHandle = TofitaSyscalls.GetMessage
			process.awaitsGetMessage = true
		}

		return true
	}

	if syscall == TofitaSyscalls.PostMessage {
		if !probeForReadOkay(frame.rdxArg1, sizeOf<PostMessagePayload>()) {
			return false
		}

		var payload = frame.rdxArg1 as! PostMessagePayload

		frame.raxReturn = postMessage(process, payload).toZeroOrOne

		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.SwapWindowFramebuffer {
		// TODO should actually be probe for copy to stack
		// Another idea: copy to safe 4k buffer and cast from it
		// ^ well actually to know proper sizeof code gen would be better
		// Also: could be locking virtual memory altering syscalls while handling them
		// Anyway must guard the logic itself in probing, like returning optional null from probeForRead on fail
		if !probeForReadOkay(frame.rdxArg1, sizeOf<SwapWindowFramebufferPayload>()) {
			return false
		}

		let payload = frame.rdxArg1 as! SwapWindowFramebufferPayload

		// TODO should copy from stack complete filled fb to this location
		// TODO not that (ptr + size) should be saturating add, to not wrap around,
		// cause otherwise it will be again under <lower and pass checks for
		// user memory pointer validity, but be pointing at kernel memory
		if !probeForWriteOkay((payload.fb as! UInt64), sizeOf<WindowFramebuffer>()) {
			return false
		}

		var windowId: UInt64 = payload.windowId

		var fb = payload.fb as! WindowFramebuffer
		var window = overlappedWindow_find(process.pid, windowId)

		if window == null {
			return false
		}

		let width = window.width
		let height = window.height
		let bytes = width * height * sizeOf<Pixel32>()

		if window.fbZeta != null {
			window.fbCurrentZeta = !window.fbCurrentZeta
			if window.fbCurrentZeta {
				// TODO triple buffer: screen<-fb<-zeta and no gama
				tmemcpy(window.fbZeta.pixels as! ArrayPointer<UInt8>, window.fbGama.pixels as! ConstArrayPointer<UInt8>, bytes)
				// TODO pixels should be within process memory space
				fb.pixels = window.fbZeta.pixels as! UInt64 // as! Pixel32
				fb.width = window.fbZeta.width
				fb.height = window.fbZeta.height
			} else {
				tmemcpy(window.fbGama.pixels as! ArrayPointer<UInt8>, window.fbZeta.pixels as! ConstArrayPointer<UInt8>, bytes)
				fb.pixels = window.fbGama.pixels as! UInt64 // as! Pixel32
				fb.width = window.fbGama.width
				fb.height = window.fbGama.height
			}
		} else {
			serialPrintln("TofitaSyscalls.SwapWindowFramebuffer window.fbZeta == null")
		}

		//		if window != null {
		//			var pixelsKernel = window.fbKernel.pixels
		//			var pixelsUser = window.fbUser.pixels
		//			let count = window.fbKernel.width * window.fbKernel.height
		//			for i in count
		//			{
		//				pixelsKernel[i] = pixelsUser[i]
		//			}
		//		}

		// frame.raxReturn = 0
		process.schedulable = true
		return true
	}

	if syscall == TofitaSyscalls.GetOrCreateWindowFramebuffer {
		if !probeForReadOkay(frame.rdxArg1, sizeOf<SwapWindowFramebufferPayload>()) {
			return false
		}

		let payload = frame.rdxArg1 as! SwapWindowFramebufferPayload

		// TODO probeForWriteOkay alias taking pointer probeForWriteAtOkay
		if !probeForWriteOkay((payload.fb as! UInt64), sizeOf<WindowFramebuffer>()) {
			return false
		}

		var windowId: UInt64 = payload.windowId

		var fb = payload.fb as! WindowFramebuffer
		var window = overlappedWindow_find(process.pid, windowId)

		if window == null {
			return false
		}

		// TODO resize fb *here* on window size change
		if window.fbZeta == null {
			let width = window.width
			let height = window.height

			let bytes = width * height * sizeOf<Pixel32>()
			// serialPrintln("[GetOrCreateWindowFramebuffer.allocateBytes]")
			// window.fbZeta.pixels = PhysicalAllocator.allocateBytes(bytes) as! Pixel32
			// window.fbGama.pixels = PhysicalAllocator.allocateBytes(bytes) as! Pixel32

			// TODO client width
			window.fbZeta = allocateBitmap(width, height)
			window.fbGama = allocateBitmap(width, height)

			memset(window.fbZeta.pixels as! ArrayPointer<UInt8>, 0x33, bytes)
			memset(window.fbGama.pixels as! ArrayPointer<UInt8>, 0x33, bytes)

			// window.fbZeta.width = width // TODO client width
			// window.fbZeta.height = height
			// window.fbGama.width = width // TODO client width
			// window.fbGama.height = height
		}

		if window.fbCurrentZeta {
			fb.pixels = window.fbZeta.pixels as! UInt64
			fb.width = window.fbZeta.width
			fb.height = window.fbZeta.height
		} else {
			fb.pixels = window.fbGama.pixels as! UInt64
			fb.width = window.fbGama.width
			fb.height = window.fbGama.height
		}

		// frame.raxReturn = 0
		process.schedulable = true
		return true
	}

	return false
}
