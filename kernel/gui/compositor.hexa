// The Tofita Kernel
// Copyright (C) 2022-2023 Oleh Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Performs screen composition of all user interface

// Note: ACCURACY is PREFERRED over SPEED, that's why we do full 2D composition even without GPU

// Differential composition is not yet supported, performance with large amount of apps may be low

var wallpaper Bitmap32 = null // Size of framebuffer
var vibranceLight Bitmap32 = null // Size of framebuffer
var vibranceDark Bitmap32 = null // Size of framebuffer
var leaves Bitmap32 = null
var trashCan Bitmap32 = null
var notepad16 Bitmap32 = null
var notepad48 Bitmap32 = null
var app16 Bitmap32 = null
var link Bitmap32 = null
var startUserIcon Bitmap32 = null
var startGearIcon Bitmap32 = null
var startDownloadsIcon Bitmap32 = null
var startGalleryIcon Bitmap32 = null
var startPowerIcon Bitmap32 = null
var startFilesIcon Bitmap32 = null
var startSearchIcon Bitmap32 = null
var startSearchOutIcon Bitmap32 = null
var traySearchIcon Bitmap32 = null
var cur Cursor = null
var darkTheme Bool = true
var startupAnimation UInt16 = 0
var desktopFilesList [String] = []
var pinnedFilesList [String] = []
var versionText = ""

enum WallpaperStyle : UInt8 {
	Center
	Stretch
	Fill
	// TODO more options
}

fun setWallpaper(bitmap Bitmap32, style WallpaperStyle, preserveAspectRatio Bool = true) {
	var bitmap = bitmap

	{
		serialPrintln("[compositor.setWallpaper] upscale wallpaper to screen size")

		var scaler = 1.0
		var scalerY = 1.0

		if _framebuffer.width > bitmap.width {
			// TODO just use float / division not \
			// TODO lmao not works in code gen `scaler = (_framebuffer.width as Float) / (bitmap.width as Float)`
			// TODO 123.toFloat without `()` and toFloat32 for compatible sizes
			scaler = (_framebuffer.width as! Float) / (bitmap.width as! Float)
		}

		if _framebuffer.height > bitmap.height {
			// TODO just use float / division not \
			scalerY = (_framebuffer.height as! Float) / (bitmap.height as! Float)
		}

		// TODO more to Theme and re-scale on-demand
		if not preserveAspectRatio {
			scaler = 1.0
		} else {
			if scalerY > scaler {
				scaler = scalerY
			}
		}

		let newWidth = (bitmap.width * scaler * 0 + 1088) as! UInt32
		let newWidth = (bitmap.width * scaler) as! UInt32
		let newHeight = (bitmap.height * scaler * 0 + 1088) as! UInt32
		let newHeight = (bitmap.height * scaler) as! UInt32

		var upscale Bitmap32 = allocateBitmap(newWidth, newHeight)

		let hReciprocal = 1.0f32 / (newHeight as! Float32)
		let wReciprocal = 1.0f32 / (newWidth as! Float32)

		// TODO don't interpolate if size the same as the screen
		// TODO rename _framebuffer to `Screen.` elsewhere
		for y in upscale.height {
			for x in upscale.width {
				let rgba = interpolatePixel(
					bitmap,
					(x * wReciprocal) * bitmap.width as! Float32, // TODO `as! _` or something
					(y * hReciprocal) * (bitmap.height - 8) as! Float32
				)
				upscale.pixels[y * upscale.width + x].ref.rgba.ref.r = rgba.ref.r
				upscale.pixels[y * upscale.width + x].ref.rgba.ref.g = rgba.ref.g
				upscale.pixels[y * upscale.width + x].ref.rgba.ref.b = rgba.ref.b
			}
		}

		wallpaper = upscale
		bitmap = wallpaper
	}

	var blurScale UInt8 = 8

	// TODO blur is at wrong position due to centering after rescale
	// it must be offset and than crop to the screen too
	var downscale Bitmap32 = allocateBitmap(
		bitmap.width / blurScale - 1u32, // TODO infer int types, also integer division
		bitmap.height / blurScale - 1u32 + 8
	)

	for y in downscale.height - 8 {
		for x in downscale.width {
			downscale.pixels[y * downscale.width + x].ref.color =
				bitmap.pixels[y * bitmap.width * blurScale + x * blurScale].ref.color
		}
	}

	// Fix
	for y in downscale.height - 8 ... downscale.height {
		for x in downscale.width {
			downscale.pixels[y * downscale.width + x].ref.color =
				bitmap.pixels[bitmap.width * (bitmap.height - 1) + x * blurScale].ref.color
		}
	}
	// TODO Theme.greyScale
	// ^ also affect icons and previews optionally

	// TODO fix blur for small wallpapers (centered smaller than screen)
	var blur Bitmap32 = gaussBlur(downscale, 4)

	// Upscale
	// TODO half-res rendering of vibrance by default
	// TODO add noise
	var upscaleLight Bitmap32 = allocateBitmap(bitmap.width, bitmap.height)
	var upscaleDark Bitmap32 = allocateBitmap(bitmap.width, bitmap.height)
	var upscale Bitmap32 = upscaleDark

	let hReciprocal = 1.0f32 / (upscale.height as! Float32)
	let wReciprocal = 1.0f32 / (upscale.width as! Float32)

	for y in upscale.height as! UInt64 {
		for x in upscale.width as! UInt64 {
			let rgbaSource =
				interpolatePixel(
					downscale,
					(x * wReciprocal) * downscale.width as! Float32, // TODO UInt32 is precise than Float32
					(y * hReciprocal) * (downscale.height - 8) as! Float32
				)

			// Apply vibrance (frosted glass)
			// 0.66*255 = 168.3
			/// rgba.r = Blend255(rgba.r, 255, 168)
			/// rgba.g = Blend255(rgba.g, 255, 168)
			/// rgba.b = Blend255(rgba.b, 255, 168)

			{
				var rgba = rgbaSource
				var rgba = rgba.ref
				rgba.r = blend255(rgba.r, 0, 168)
				rgba.g = blend255(rgba.g, 0, 168)
				rgba.b = blend255(rgba.b, 0, 168)
				// TODO upscaleDark.pixels[y * upscale.width + x].ref.rgba = rgba
				upscaleDark.pixels[y * upscale.width + x].ref.rgba.ref.r = rgba.r
				upscaleDark.pixels[y * upscale.width + x].ref.rgba.ref.g = rgba.g
				upscaleDark.pixels[y * upscale.width + x].ref.rgba.ref.b = rgba.b
			}

			{
				var rgba = rgbaSource
				var rgba = rgba.ref
				rgba.r = blend255(rgba.r, 255, 168)
				rgba.g = blend255(rgba.g, 255, 168)
				rgba.b = blend255(rgba.b, 255, 168)
				// TODO upscaleLight.pixels[y * upscale.width + x].ref.rgba = rgba
				upscaleLight.pixels[y * upscale.width + x].ref.rgba.ref.r = rgba.r
				upscaleLight.pixels[y * upscale.width + x].ref.rgba.ref.g = rgba.g
				upscaleLight.pixels[y * upscale.width + x].ref.rgba.ref.b = rgba.b
			}
		}
	}

	vibranceDark = upscaleDark
	vibranceLight = upscaleLight
}

fun drawVibrancedRectangle(x Int16, y Int16, width UInt16, height UInt16, dark Bool = true) {
	let vibrance = dark ? vibranceDark : vibranceLight // Avoid non-register global access
	for yy in height {
		for xx in width {
			if x + xx < 0 {
				continue
			}
			if x + xx > vibrance.width {
				continue
			}
			if y + yy < 0 {
				continue
			}
			if y + yy > vibrance.height {
				continue
			}
			var pixel UInt32 = (y + yy) * vibrance.width + xx + x as! UInt32
			setPixel(x + xx, y + yy, vibrance.pixels[pixel])
		}
	}
}

fun initializeCompositor() {
	serialPrintln("[compositor.initializeCompositor] begin")
	// TODO must require `*=` and not `* =` for assign-ops
	Screen.doublebuffer = allocateBitmap(_framebuffer.width, _framebuffer.height)
	_pixels = Screen.doublebuffer.pixels

	Screen.pixels = Screen.doublebuffer.pixels
	Screen.width = Screen.doublebuffer.width
	Screen.height = Screen.doublebuffer.height
	Screen.widthMinusOne = Screen.doublebuffer.width - 1
	Screen.heightMinusOne = Screen.doublebuffer.height - 1

	// Start

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/user.png")
	startUserIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/gear.png")
	startGearIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/downloads.png")
	startDownloadsIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/gallery.png")
	startGalleryIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/power.png")
	startPowerIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/files.png")
	startFilesIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/search.png")
	startSearchIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/pip.png")
	startSearchOutIcon = loadPng32(a)

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/leaves.png")
	leaves = loadPng32(a)

	// Tray

	let a = new RamDiskAsset()
	getRamDiskAsset(a, "root/Windows/Resources/Icons/Start/find.png")
	traySearchIcon = loadPng32(a)

	// Desktop

	let b = new RamDiskAsset()
	getRamDiskAsset(b, "root/Windows/Resources/Icons/trash-empty48.png")
	trashCan = loadPng32(b)

	let c = new RamDiskAsset()
	getRamDiskAsset(c, "root/Windows/Resources/Icons/notepad.ico_48x48.png")
	notepad48 = loadPng32(c)

	let d = new RamDiskAsset()
	getRamDiskAsset(d, "root/Windows/Resources/Icons/notepad.ico_16x16.png")
	notepad16 = loadPng32(d)

	let e = new RamDiskAsset()
	getRamDiskAsset(e, "root/Windows/Resources/Icons/link.png")
	link = loadPng32(e)

	let asset = new RamDiskAsset()
	getRamDiskAsset(asset, "root/Windows/Resources/Icons/app16.png")
	app16 = loadPng32(asset)

	// TODO move all those assets to desktop.hexa ^ taskbar.hexa

	let asset = new RamDiskAsset()
	getRamDiskAsset(asset, "desktop")
	{
		serialPrintf("root/Windows/Resources/Icons: %d\n", asset.size)
		var length = 0
		var at = 0u64 // TODO should work with 0u32 too
		for i in asset.size {
			// TODO `'\n'.charCodeAt(0)`
			// if i % 2 == 1 and asset.data[i] == 10 {
			if (i % 2 == 0) and (asset.data[i] == 10) {
				let offset = (asset.data as! UInt64) + at + 0u64
				let file = String.fromUTF16zUpTo(offset as! ConstArrayPointer<UInt16>, length / 2)
				at = i + 2u64
				length = 0
				desktopFilesList.push(file)
			} else {
				length++
			}
		}

		// TODO
		pinnedFilesList = desktopFilesList
	}

	let asset = new RamDiskAsset()
	getRamDiskAsset(asset, "root/Windows/Cursors/aero_arrow.cur")
	// TODO cur = loadCursor(Buffer.fromBytes(asset.data))
	cur = loadCursor(asset)
	initCursorBackplate()

	serialPrintln("[compositor.initializeCompositor] done")
}

fun compositeWindows() {
	var i = rootWindow
	// Avoid infinite loop
	for loop in windowsLimit {
		let window = windowsList[i]

		// TODO proper iteration
		if window == null {
			continue
		}

		// TODO better use max int or whatever instead of 0 for desktop window/others
		if i != 0 && window.present && window.visible && not window.minimized {
			let hover = frameHoverWindow == i ? frameHoverState : FrameHover.Noop

			drawWindowFrame(
				window.title,
				window.x,
				window.y,
				// TODO frameHeight & frameWidth in overlappedWindow_create
				window.width + 2,
				window.height + 34,
				firstResponder == i,
				hover,
				// Note this is kinda different than original
				// but I like it more this way
				frameHoverWindowDown and frameHoverWindowInsideButtonArea
			)

			// TODO just untyped `let frameHeight = 30 + 3`, see below
			// TODO also `let frameHeight Int16 = 30 + 3`
			let frameHeight Int16 = 30 + 3i16
			let frameWidth Int16 = 1i16

			if window.fbZeta != null && window.fbGama != null {

				drawBitmap32(window.fbCurrentZeta ? window.fbZeta : window.fbGama, window.x + frameWidth,
							 window.y + frameHeight)
			} else {
				drawVibrancedRectangle(
					window.x + frameWidth, // TODO late-infer-fix int type
					window.y + frameHeight,
					window.width,
					window.height,
					darkTheme
				)
			}
		}

		// TODO does this imply that [0] is valid to get nextId?
		i = windowsList[i].nextId
		if i == 0 {
			break
		}
	}
}

/// Forces repaint
fun requestAnimationFrame() {
	haveToRender = true
}

fun composite(startupMilliseconds UInt64) {
	let mouseX = mouseX
	let mouseY = mouseY

	// Startup animation
	if startupAnimation < 2000 {
		requestAnimationFrame()
	 	startupAnimation += 9 * 2u16
	}

	// TODO non-centered drawBitmap32(wallpaper, 0, 0)
	drawBitmap32(
		wallpaper,
		// TODO pre-compute and save those coordinates
		(_framebuffer.width / 2i16) - (wallpaper.width / 2i16),
		(_framebuffer.height / 2i16) - (wallpaper.height / 2i16)
	)

	// Desktop icons
	drawBitmap32WithAlpha(trashCan, 14i16, 10i16)
	var color = new ByValue<Pixel32>()
	color.ref.color = 0x00000000
	let shadowTextWidth = 76u16 - 8u16
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8
	drawShadowText("Recycle Bin", 8, 62i16, shadowTextWidth, color.ref) // TODO infer i16

	let yOffset = 12i16 + 48i16 + 10i16 + 4i16 + 16i16
	var xu = 0i16
	var yu = yOffset
	// TODO not inferred properly?
	// for file in desktopFilesList as! [String] {
	for i in desktopFilesList.length {
		let file = desktopFilesList[i] // TODO [ ] must return T? not T

		// TODO `\r`
		if file.utf16()[0] as! UInt16 == 13u16 {
			drawBitmap32WithAlpha(folder48, 14i16 + xu, yu)
		} else {
			// TODO endsWith
			if file.utf16()[file.length - 1] as! UInt16 == 101 {
				// TODO read real icon
				drawBitmap32WithAlpha(app48, 14i16 + xu, yu)
			} else {
				// TODO real preview for pics
				drawBitmap32WithAlpha(unknown48, 14i16 + xu, yu)
			}
		}

		color.ref.color = 0x00000000
		let textX = 2 + xu

		// TODO light theme
		color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8
		drawShadowText(file, textX, 62i16 + yu, shadowTextWidth, color.ref) // TODO infer i16
		// TODO Hexa: must work `yu += 32`
		// `yu += 32i16`
		yu += yOffset

		let taskbarHeight = 30 // TODO
		if (yu + yOffset) > (_framebuffer.height - taskbarHeight) {
			// TODO should work yu = 10 but not -10 for unsigned
			yu = 10i16
			xu += yOffset
		}
	}

	color.ref.rgba.ref.a = 64
	// TODO move to DWM handleMouseMove etc
	if mouseX > 20 && mouseX < (20 + 32) && mouseY > 12 && mouseY < (12 + 60) {
		let outlineX = 1i16
		let outlineY = 10i16
		let outlineW = 72u16
		let outlineH = 64u16
		drawRectangleWithAlpha(color.ref, outlineX, outlineY, outlineW, outlineH)
		drawRectangleOutline(color, outlineX, outlineY, outlineW, outlineH)
	}

	// Desktop is below everything
	compositeDesktop(mouseX, mouseY)

	// Windows are below taskbar
	compositeWindows()

	// Taskbar
	let animationTaskbarY = Math.min(startupAnimation / 1555.0, 1.0) * 30
	drawVibrancedRectangle(
		0,
		_framebuffer.height - animationTaskbarY as! Int16, // TODO upcast `a - b` to larger type
		_framebuffer.width as! UInt16,
		30,
		darkTheme
	)

	let taskbarY = _framebuffer.height + 30 - animationTaskbarY * 2.0
	let taskbarY = taskbarY as! Int16

	// Start button
	// TODO make pad an option
	let leavesPadding = true
	var leavesPad = 0u16
	if leavesPadding {
		leavesPad = 2u16
	}
	color.ref.rgba.ref.a = 128
	color.ref.rgba.ref.a = 100
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0x61u8

	// Save the color
	// TODO different color for light theme
	let hoverColor = color
	let holdColor = color
	holdColor.ref.rgba.ref.a = 64

	if let rectangle = defaultSession.taskbarStart, rectangle.mouseOver {
		drawRectangleWithAlpha(
			rectangle.mouseHold? holdColor.ref : hoverColor.ref,
			0,
			taskbarY,
			40 + leavesPad + leavesPad,
			30
		)
	}

	// TODO more lr space around for beauty
	// TODO create Theme class with static fields
	// TODO ^ move other elements to the right
	// TODO finally unify, use Int16 ot UInt16 everywhere lol!
	drawBitmap32WithAlpha(leaves, leavesPad + 2i16, taskbarY + 2i16)
	// TODO ^ white leaves or dynamically recolored depending on wallpaper or something
	// ^ change color on hover

	// TODO smooth transition between light and dark theme!
	// ^ drawVibrancedRectangle should just take info from Theme directly,
	// and dark-light transition from there too + it will request animation frame on it own
	// TODO draw differentially (optimization) desktop/windows/taskbar (full overlap detection?)

	// Taskbar shortcuts (pins)
	// TODO just use specs from collider
	let shortcutsWidth = 36u16 // 24 is too small
	// TODO respect leaves padding
	let shortcutsIconX = 44i16 + (shortcutsWidth / 2i16) - (16 / 2i16)
	let shortcutsEnd = shortcutsWidth + 44
	if let rectangle = defaultSession.taskbarPin, rectangle.mouseOver {
		drawRectangleWithAlpha(
			rectangle.mouseHold? holdColor.ref : hoverColor.ref,
			44i16,
			taskbarY,
			shortcutsWidth,
			30
		)
	}
	drawBitmap32WithAlpha(notepad16, shortcutsIconX, taskbarY + 7i16)

	// Version
	{
		let name = "Greentea OS Insider Preview"
		let color = new ByValue<Pixel32>()
		color.ref.color = 0xFFFFFFFFu32
		drawTextBox(name, _framebuffer.width - getTextAdvance(name) - 5i16, taskbarY - 32i16, color.ref, 512, 32, true)
		drawTextBox(versionText, _framebuffer.width - getTextAdvance(versionText) - 5i16, taskbarY - 16i16, color.ref, 512, 32, true)
	}

	// Opened windows
	// Sorted in the creation order
	var i = rootWindow
	var windowIndex = 0
	// Avoid infinite loop
	for loop in windowsLimit {
		let window = windowsList[i]

		// TODO proper iteration
		if window == null {
			continue
		}

		// TODO and visible?
		if i != 0 && window.present {
			var rectangle = defaultSession.taskbarWindowList.children[0]
			for r in defaultSession.taskbarWindowList.children.length {
				let rect = defaultSession.taskbarWindowList.children[r]
				if rect.id == i {
					// TODO Yeah, could just use Array.find
					rectangle = rect
				}
			}

			// TODO if window.visible
			// TODO ellipsis
			// TODO more windows - less width
			// TODO measure default width
			let w = 148u16
			let x = shortcutsEnd + windowIndex * w
			let y = _framebuffer.height - 30i16
			if firstResponder == i {
				color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xAAu8
				color.ref.rgba.ref.a = 64
				drawRectangleWithAlpha(color.ref, x + 2i16, y, w - 4u16, 26u16)
				color.ref.rgba.ref.a = 100
			} else {
				if let rectangle = rectangle, rectangle.mouseOver {
					drawRectangleWithAlpha(
						rectangle.mouseHold? holdColor.ref : hoverColor.ref,
						rectangle.relativeX + defaultSession.taskbarWindowList.relativeX,
						taskbarY,
						rectangle.width as! UInt16,
						30
					)
				}
			}
			color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xAAu8
			// TODO proper app icon
			drawBitmap32WithAlpha(app16, x + 6i16, y + 5i16)
			// TODO widthLimit Int16, wrapAround Bool, heightLimit Int16
			let appTitleOffset = 29
			drawTextBox(window.title, x + appTitleOffset, y + 10i16, color.ref, w - appTitleOffset, 32, true)
			// TODO full width in active
			// TODO animate
			// TODO to not look like win10 by default, draw them as vertical
			// gradients as I did want long ago!!!
			drawRectangleWithAlpha(color.ref, x + 2i16, y + 26i16, w - 4u16, 4u16)
			windowIndex++
		}

		i++
	}

	// TODO tray space should be computed *before* window list

	// Tray | line
	if let rectangle = defaultSession.taskbarDesktopPeek, rectangle.mouseOver {
		drawRectangleWithAlpha(
			rectangle.mouseHold? holdColor.ref : hoverColor.ref,
			rectangle.relativeX,
			taskbarY,
			// TODO some proper conversion like `Int16.clampToUInt16(value)` or as method
			rectangle.width as! UInt16,
			30
		)
	}
	color.ref.color = 0x00000000
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0x66u8
	drawRectangle(color, _framebuffer.width - 4i16, taskbarY, 1, 30)

	var trayButtonX = _framebuffer.width - 20 - 16i16
	trayButtonX = _framebuffer.width - 80i16
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0x11u8
	color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8

	// Time
	if let rectangle = defaultSession.taskbarTime, rectangle.mouseOver {
		drawRectangleWithAlpha(
			rectangle.mouseHold? holdColor.ref : hoverColor.ref,
			rectangle.relativeX,
			taskbarY,
			rectangle.width as! UInt16,
			30
		)
	}
	let timeMilliseconds = uptimeMilliseconds + startupMilliseconds
	var uptimeHours = (timeMilliseconds / (60 * 60 * 1000)) as! Int64
	while uptimeHours >= 24 {
		uptimeHours -= 24
	}

	// TODO must subtract days here too, like `-= 24` for hours
	let uptimeMinutes = ((timeMilliseconds - (uptimeHours * (60 * 60 * 1000))) / (60 * 1000)) as! UInt8

	// TODO theme should decide AM/PM or 24H format
	var pm Bool = uptimeHours >= 12
	if uptimeHours > 12 {
		uptimeHours -= 12
	}

	let trayTimeStartX = trayButtonX + 20
	var trayTimeX = trayTimeStartX + 4
	trayTimeX += drawIntegerText(uptimeHours, trayTimeX, taskbarY + 10i16, color.ref)
	trayTimeX += drawAsciiText(":", trayTimeX, taskbarY + 10i16, color.ref)
	if uptimeMinutes < 10 {
		trayTimeX += drawAsciiText("0", trayTimeX, taskbarY + 10i16, color.ref)
	}
	trayTimeX += drawIntegerText(uptimeMinutes, trayTimeX, taskbarY + 10i16, color.ref)
	trayTimeX += drawAsciiText(pm ? " PM" : " AM", trayTimeX, taskbarY + 10i16, color.ref)

	// Input language
	if let rectangle = defaultSession.taskbarInput, rectangle.mouseOver {
		drawRectangleWithAlpha(
			rectangle.mouseHold? holdColor.ref : hoverColor.ref,
			rectangle.relativeX,
			taskbarY,
			rectangle.width as! UInt16,
			30
		)
	}
	let languageId = 'ENG'
	let languagePad = 8
	var trayLanguageX = trayTimeStartX - getTextAdvance(languageId) - languagePad * 2
	drawAsciiText(languageId, trayLanguageX, taskbarY + 10i16, color.ref)

	// Tray ^ button
	// TODO Hexa: try `if let item = defaultSession.taskbarTrayOpener, item.mouseOver { item.xxx }` pattern
	if defaultSession.taskbarTrayOpener.mouseOver {
		drawRectangleWithAlpha(
			defaultSession.taskbarTrayOpener.mouseHold? holdColor.ref : hoverColor.ref,
			defaultSession.taskbarTrayOpener.relativeX,
			taskbarY,
			defaultSession.taskbarTrayOpener.width as! UInt16,
			30
		)
	}

	trayButtonX = trayLanguageX - languagePad - 16i16

	line45smooth(color, trayButtonX, taskbarY + 10 + 2i16, 6i16, 1i16)
	line45smooth(color, trayButtonX + 1i16, taskbarY + 10 + 2i16, 6i16, -1i16)

	// Search
	if defaultSession.taskbarSearch.mouseOver {
		drawRectangleWithAlpha(
			defaultSession.taskbarSearch.mouseHold? holdColor.ref : hoverColor.ref,
			defaultSession.taskbarSearch.relativeX,
			taskbarY,
			defaultSession.taskbarSearch.width as! UInt16,
			30
		)
	}

	drawBitmap32WithAlpha(
		traySearchIcon,
		// TODO probably compute global positions for all once in the begin of composition?
		defaultSession.taskbarSearch.relativeX + 5i16,
		taskbarY + 4i16
	)

	// Tray
	if defaultSession.showTray {
		let w = defaultSession.taskbarTrayOpener.width * 3 as! UInt16
		let h = defaultSession.taskbarTrayOpener.width * 3 as! UInt16
		let x = defaultSession.taskbarTrayOpener.relativeX - defaultSession.taskbarTrayOpener.width
		let y = taskbarY - h
		drawVibrancedRectangle(x, y as! Int16, w, h, darkTheme)
		// TODO probably `w - 2` to avoid some overdraw?
		color.ref.color = 0x126099FF
		drawRectangleOutline(color, x, y as! Int16, w, h)

		let color = hoverColor
		color.ref.rgba.ref.a += 32u8

		for xx in 3 {
			for yy in 3 {
				drawRectangleWithAlpha(
					color.ref,
					// TODO instead of +1 do 2px wider outline
					1 + (defaultSession.taskbarTrayOpener.width * xx) + x,
					1 + (defaultSession.taskbarTrayOpener.width * yy) + y as! Int16,
					defaultSession.taskbarTrayOpener.width as! UInt16,
					defaultSession.taskbarTrayOpener.width as! UInt16
				)
				color.ref.rgba.ref.a -= 16u8
			}
		}
	}

	// Start
	if defaultSession.showStart {
		let w = 640u16
		// TODO should fit into 720p
		let h = 730u16
		// TODO centered mode
		let x = 0i16
		// TODO gap above taskbar in centered mode
		let y = taskbarY - h
		drawVibrancedRectangle(x, y as! Int16, w, h, darkTheme)
		// TODO probably `w - 2` to avoid some overdraw?
		color.ref.color = 0x44444444u32
		drawRectangleOutline(color, x, y as! Int16, w, h)

		// Interior
		{
			// Layout
			let userPanelHeight = 64i16
			let pinsPanelHeight = 500i16
			// TODO capture click zone inside Start so it is not auto closed on click itself
			// TODO internal colliders and their hover/hold states

			// Pins panel
			{
				// Items
				drawPinnedItems(x, y + 24i16 + userPanelHeight, w + 0i16, pinsPanelHeight)

				color.ref.color = 0x0A385999
				let title = "Pinned apps and files"
				drawTextBox(title, x + 16, y + 15i16 + userPanelHeight, color.ref, w, 32, true)

				// Scroll "bar"
				let currentScrollIndex = 1 // TODO
				let scrollIndexes = 3u16
				let scrollWidth = 6u16
				color.ref.color = 0xF0F0F0
				color.ref.rgba.ref.a = 128

				for index in scrollIndexes {
					// TODO Hexa: infer constant types here
					color.ref.rgba.ref.a = index == currentScrollIndex? 128u8 : 64u8
					drawRectangleWithAlpha(
						color.ref,
						x + w - scrollWidth - 12i16,
						// TODO current larger by h + 2px
						y + userPanelHeight + (pinsPanelHeight / 2i16 - scrollWidth) + (index * scrollWidth * 2i16),
						scrollWidth,
						scrollWidth
					)
				}
			}

			// User panel
			{
				color.ref.color = 0x126099FF
				color.ref.rgba.ref.a = 128
				lineHorizontalWithAlpha(color.ref, x, y + userPanelHeight, w)

				color.ref.rgba.ref.r = 8
				color.ref.rgba.ref.g = 8
				color.ref.rgba.ref.b = 8
				drawRectangleWithAlpha(
					color.ref,
					x + 1i16,
					y + 1i16,
					w - 2,
					userPanelHeight - 2u16
				)

				// TODO user pic
				// TODO click anywhere but the pic to open home folder
				drawBitmap32WithAlpha(startUserIcon, x + 16i16, y + userPanelHeight / 2 - 16i16)

				// Shortcuts
				drawBitmap32WithAlpha(startPowerIcon, x + w - 48 * 1i16, y + userPanelHeight / 2 - 16i16)
				drawBitmap32WithAlpha(startGearIcon, x + w - 48 * 2i16, y + userPanelHeight / 2 - 16i16)
				drawBitmap32WithAlpha(startFilesIcon, x + w - 48 * 3i16, y + userPanelHeight / 2 - 16i16)
				drawBitmap32WithAlpha(startGalleryIcon, x + w - 48 * 4i16, y + userPanelHeight / 2 - 16i16)
				drawBitmap32WithAlpha(startDownloadsIcon, x + w - 48 * 5i16, y + userPanelHeight / 2 - 18i16)

				color.ref.color = 0xFFFFFFFFu32
				let welcome = "Hello, dear User"
				drawTextBox(welcome, x + 16 + 32 + 15, y + 29i16, color.ref, w, 32, true)
			}

			// All apps panel
			{
				let panelY = y + userPanelHeight + pinsPanelHeight
				let panelHeight = h - userPanelHeight * 2 - pinsPanelHeight + 0u16

				color.ref.rgba.ref.r = 8
				color.ref.rgba.ref.g = 8
				color.ref.rgba.ref.b = 8
				color.ref.rgba.ref.a = 128
				drawRectangleWithAlpha(
					color.ref,
					x + 1i16,
					panelY,
					w - 2,
					panelHeight
				)

				color.ref.color = 0x0A385999
				let title = "Apps and suggestions"
				drawTextBox(title, x + 16, panelY + 15i16, color.ref, w, 32, true)

				// "All apps"
				color.ref.color = 0x99999999u32
				let button = "Show all apps..."
				drawTextBox(button, x + w / 2, panelY + panelHeight / 2 - 6i16, color.ref, w, 32, true)

				// _ _ _ blocks
				let blockWidth = 32i16
				color.ref.color = 0xF0F0F0
				color.ref.rgba.ref.a = 32
				for index in 3 {
					drawRectangleWithAlpha(
						color.ref,
						w / 2 - blockWidth - blockWidth / 2i16 - index * blockWidth - index * blockWidth / 2i16,
						panelY + panelHeight / 2 - blockWidth / 2i16,
						blockWidth + 0u16,
						blockWidth + 0u16
					)

					// Small shortcut-like element
					drawRectangleWithAlpha(
						color.ref,
						w / 2 - blockWidth - blockWidth / 2i16 - index * blockWidth - index * blockWidth / 2i16,
						panelY + panelHeight / 2 - blockWidth / 2i16 + (blockWidth / 4i16) * 3i16,
						blockWidth / 4u16,
						blockWidth / 4u16
					)
				}
			}

			// Search panel
			// This panel is here for:
			// 1. Discover-ability: users should know that search in Start menu is possible
			// 2. Aesthetics: looks way better than not having one
			// 3. Familiarity: being above is good for older users
			{
				// TODO Text edit: focus, caret and kb input
				let inputY = y + h - userPanelHeight + 29i16

				// Darken only under the text field
				color.ref.rgba.ref.r = 8
				color.ref.rgba.ref.g = 8
				color.ref.rgba.ref.b = 8
				drawRectangleWithAlpha(
					color.ref,
					x + 10i16,
					inputY - 8i16,
					w - 22,
					24
				)

				color.ref.color = 0xFFFFFFFFu32
				let welcome = "Type anything to start search"
				drawTextBox(welcome, x + 16 + 22, inputY, color.ref, w, 32, true)

				drawBitmap32WithAlpha(startSearchIcon, x + 12i16, inputY - 8i16)
				drawBitmap32WithAlpha(startSearchOutIcon, x + w - 24 - 12i16, inputY - 8i16)

				// Cool hairline
				color.ref.color = 0x129999FF
				color.ref.rgba.ref.a = 128
				lineHorizontalWithAlpha(color.ref, x + 12i16, inputY + 16i16, w - 24)
			}
		}
	}

	// HUD
	quake()
	invalidateCursorBackplate(mouseX as! UInt16, mouseY as! UInt16)
	drawCursor(cur, mouseX as! UInt16, mouseY as! UInt16)
}

// TODO scrollOffsetY Int16
/// Render the pinned apps and files
fun drawPinnedItems(x Int16, y Int16, w Int16, h Int16) {
	let yOffset = 12i16 + 48i16 + 10i16 + 4i16 + 16i16
	let startX = 10 + x
	var xu = startX
	var yu = 12 + y
	let color = new ByValue<Pixel32>()

	// TODO draw =P when zero pinned and show built-in apps in recommendations
	for i in pinnedFilesList.length {
		let file = pinnedFilesList[i]

		if file.utf16()[0] as! UInt16 == 13u16 {
			drawBitmap32WithAlpha(folder48, 14i16 + xu, yu)
		} else {
			// TODO endsWith
			if file.utf16()[file.length - 1] as! UInt16 == 101 {
				// TODO read real icon
				drawBitmap32WithAlpha(app48, 14i16 + xu, yu)
			} else {
				// TODO real preview for pics
				drawBitmap32WithAlpha(unknown48, 14i16 + xu, yu)
			}
		}

		color.ref.color = 0x00000000
		let shadowTextWidth = 76u16 - 8u16
		let textX = 2 + xu
		color.ref.rgba.ref.r = color.ref.rgba.ref.g = color.ref.rgba.ref.b = 0xFFu8
		drawShadowText(file, textX, 62i16 + yu, shadowTextWidth, color.ref)

		// Grid
		xu += yOffset

		if xu + yOffset > x + w {
			xu = startX
			yu += yOffset
		}

		if yu > y + h {
			break
		}
	}
}

var cursorBackplate Bitmap32 = null
var cursorBackplateX UInt16 = 0
var cursorBackplateY UInt16 = 0
// TODO class Box + fun max
var cursorDirtyX Int16 = 0
var cursorDirtyY Int16 = 0
var cursorDirtyBottomX UInt16 = 0
var cursorDirtyBottomY UInt16 = 0

fun initCursorBackplate() {
	cursorBackplate = allocateBitmap(cur.width, cur.height)
}

/// Copy current framebuffer into cache
fun invalidateCursorBackplate(x UInt16, y UInt16) {
	cursorBackplateX = x
	cursorBackplateY = y

	for yi in cur.height {
		let scanlineScreen UInt64 = Screen.width * (y + yi - cur.y + 1) - cur.x + 1 + x
		let scanline UInt64 = cursorBackplate.width * yi
		for xi in cur.width {
			cursorBackplate.pixels[scanline + xi] = Screen.pixels[scanlineScreen + xi]
		}
	}
}

/// Draw backplate onto framebuffer to emulate erase
fun drawCursorBackplate() {
	let x = cursorBackplateX
	let y = cursorBackplateY

	// Hexa: `as` here breaks code gen
	cursorDirtyX = (x as! Int16) - cur.x + 1i16
	cursorDirtyY = (y as! Int16) - cur.y + 1i16
	cursorDirtyBottomX = cursorDirtyX + cur.width
	cursorDirtyBottomY = cursorDirtyY + cur.height

	for yi in cur.height {
		let scanlineScreen UInt64 = Screen.width * (y + yi - cur.y + 1) - cur.x + 1 + x
		let scanline UInt64 = cursorBackplate.width * yi
		for xi in cur.width {
			Screen.pixels[scanlineScreen + xi] = cursorBackplate.pixels[scanline + xi]
		}
	}
}

/// Draw cursor itself
fun drawCursor(cur Cursor, x UInt16, y UInt16) {
	cursorDirtyX = (x as! Int16) - cur.x + 1i16
	cursorDirtyY = (y as! Int16) - cur.y + 1i16
	cursorDirtyBottomX = cursorDirtyX + cur.width
	cursorDirtyBottomY = cursorDirtyY + cur.height

	// TODO mirror cursor in this code if global setting for cursors mirroring is set
	// to affect all apps
	let pixel = new ByValue<Pixel32>()
	let bmp = (cur.bmp as! UInt64 + cur.bmpStart) as! ArrayPointer<UInt32>

	for yi in cur.height {
		for xi in cur.width {
			let yy UInt32 = cur.height - yi - 1u32
			pixel.ref.color = bmp[xi + yy * (cur.width as! UInt32)] as! UInt32
			blendPixel(x + xi - cur.x + 1, y + yi - cur.y + 1, pixel.ref)
		}
	}
}

/// Copy the part of back buffer to the native framebuffer
fun copyDirtyToScreen(x Int16, y Int16, bottomX Int16, bottomY Int16) {
	var source = Screen.pixels as! ArrayPointer<UInt32>
	var destination = _framebuffer.base as! ArrayPointer<UInt32>
	let width = _framebuffer.width
	let height = _framebuffer.height

	// TODO Hexa: infer `0` to `0i16` at `let y = y < 0? 0<-here : y`
	let y = y < 0? 0i16 : y
	let x = x < 0? 0i16 : x
	let bottomX = bottomX > width? width as! Int16 : bottomX
	let bottomY = bottomY > height? height as! Int16 : bottomY

	for yi in y ... bottomY {
		let scanline UInt64 = width * (yi as! UInt64)
		for xi in x ... bottomX {
			let offset UInt64 = scanline + (xi as! UInt64)
			destination[offset] = source[offset]
		}
	}
}

/// Copy the back buffer to the native framebuffer
fun copyToScreen() {
	// On 64-bit platform registers are 64-bit,
	// so lets copy two or more pixels at a time
	let height = _framebuffer.height
	// Let's assume it is always dividable by 2
	// TODO ^ add some stride to the Screen.fb itself to ensure this
	// or make loop to copy rightmost pixels separately
	let width = _framebuffer.width / 2
	let scanline UInt64 = _framebuffer.width * 4
	// TODO byte offset should respect bytes-per-pixel (may be 3?)
	let pixelsPerScanLine UInt64 = _framebuffer.pixelsPerScanLine * 4
	var source = (Screen.pixels as! UInt64) as! ArrayPointer<UInt64>
	var destination = (_framebuffer.base as! UInt64) as! ArrayPointer<UInt64>

	// TODO copy only dirty rect (at least cursor) (must be aligned to the stride too)
	for y in height {
		for x in width {
			destination[x] = source[x]
		}

		source = ((source as! UInt64) + scanline) as! ArrayPointer<UInt64>
		destination = ((destination as! UInt64) + pixelsPerScanLine) as! ArrayPointer<UInt64>
	}
}
