// The Tofita Kernel
// Copyright (C) 2020-2023 Oleh Petrenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

typedef void *EFI_HANDLE;
typedef void VOID;

#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>

typedef void function;
#ifdef __cplusplus
	constexpr auto null = nullptr;
	#define externC extern "C"
#else
	#define externC
	#define nullptr ((void*)0)
	#define null nullptr
#endif

struct UefiPayload_;
struct UefiPayload_ *kernelParams; // Used by Hexa

// Generated by Hexa compiler
#define HEXA_NO_DEFAULT_INCLUDES
#undef char
#undef int
function serialPrintf(const wchar_t *c, ...);
static void printf(const void/*chat*/ *c, ...) {
	serialPrintf(L"<Hexa> printf %s\n", c);
};
void fflush(void *pipe) {
	serialPrintf(L"<Hexa> fflush\n");
};
static void* HeapAllocAt(size_t lineNumber, char const* filename, char const* functionName, int8_t x,int8_t u, uint64_t size);
void *malloc(uint64_t bytes) {
	return (void *)HeapAllocAt(1, "unsafe", "unsafe", 1, 1, bytes);
};
function memcpy(void *dest, const void *src, uint64_t n);
int32_t wcslen(const wchar_t *string_) {
	serialPrintf(L"<Hexa> wcslen\n");
	int32_t i = 0;
	while (string_[i] != '\0')
		i++;
	return i;
};
void free(void *ptr) {
	// TODO
};
typedef void FILE;
#define HEXA_MAIN mainHexa
#define HEXA_NEW(z) malloc(z)

void *memset(void *dest, int32_t e, uint64_t len) {
	uint8_t *d = (uint8_t *)dest;
	for (uint64_t i = 0; i < len; i++, d++) {
		*d = e;
	}
	return dest;
}

function memzero(void *dest, uint64_t len) {
	memset(dest, 0, len);
}

externC void ___chkstk_ms(){};

void vmemcpy(volatile void *dest, const volatile void *src, volatile uint64_t count) {
	uint8_t *dst8 = (uint8_t *)dest;
	uint8_t *src8 = (uint8_t *)src;

	while (count--) {
		*dst8++ = *src8++;
	}
}

externC function mouseHandler();
externC function keyboardHandler();
#define PACKED __attribute__((packed))
#pragma pack(1)
typedef struct {
	uint16_t limit;
	uint64_t offset;
} PACKED Idtr;
#pragma pack()
_Static_assert(sizeof(Idtr) == 10, "IDTR register has to be 80 bits long");
#pragma pack(1)
struct TablePtr {
	uint16_t limit;
	uint64_t base;
} __attribute__((packed));
typedef struct TablePtr TablePtr;
#ifndef __cplusplus
#define char8_t uint8_t
#endif
#pragma pack()
_Static_assert(sizeof(TablePtr) == 10, "sizeof is incorrect");

#include "../devices/cpu/amd64.cpp"
#include "../devices/serial/log.cpp"
// STB library
#define STBI_NO_SIMD
#define STBI_NO_STDIO
#define STB_IMAGE_IMPLEMENTATION
#define STBI_ONLY_PNG
#include "formats/stb_image/libc.cpp"
#include "formats/stb_image/stb_image.hpp"
#include "formats/stb_image/unlibc.cpp"

#if 0
static function kernelInit(const KernelParams *params) {
	// PhysicalAllocator::init(&params->efiMemoryMap, params->physicalRamBitMaskVirtual,
	// DOWN_BYTES_TO_PAGES(params->ramBytes));
	let trapezePhysical = trapeze - (uint64_t)WholePhysicalStart;
	if (trapezePhysical > 1068032) {
		serialPrintln(L"<Tofita> cannot allocate trapeze under 1 MB");
		while (true) {}
	}

	let available = PhysicalAllocator::getAvailablePages() * 4096;
	pages::pml4entries = (pages::PageEntry *)((uint64_t)WholePhysicalStart + (uint64_t)(params->pml4));

	uint32_t megs = Math::round((double)params->ramBytes / (1024.0 * 1024.0));
	uint32_t availableMegs = Math::round((double)available / (1024.0 * 1024.0));
	quakePrintf(L"[CPU] %s %s %d MB RAM (%d MB usable)\n", cpuid.vendorID, cpuid.brandName, megs,
				availableMegs);

	// SMP trapeze
	{
		RamDiskAsset asset = getRamDiskAsset(L"trapeze.tofita");
		serialPrintf(L"Copy trapeze %d bytes\n", asset.size);
		uint64_t trapeze = (uint64_t)0x8000 + (uint64_t)WholePhysicalStart;
		tmemcpy((void *)trapeze, (const void *)asset.data, asset.size);
	}
}

function kernelThread() {
	serialPrintln(L"<Tofita> [kernelThread] thread started");

	// TODO move to preTest with infinite loop on fail
	serialPrintf(L"<seh> 0 == %u\n", probeForReadOkay((uint64_t)321, 1));
	serialPrintf(L"<seh> 1 == %u\n", probeForReadOkay((uint64_t)&currentThread, 1));
	serialPrintf(L"<seh> 0 == %u\n", probeForReadOkay((uint64_t)999999999, 1));
	serialPrintf(L"<seh> 1 == %u\n", probeForReadOkay((uint64_t)&guiStack, 1));
	serialPrintf(L"<seh> 0 == %u\n", probeForReadOkay((uint64_t)-1, 1));
	serialPrintf(L"<seh> 1 == %u\n", probeForReadOkay((uint64_t)&switchToNextProcess, 1));

	while (true) {
		volatile uint64_t index = 1; // Idle process ignored
		while (index < 255) {		 // TODO
			volatile process::Process *process = &process::processes[index];
			if (process->present == true) {
				if (process->syscallToHandle != TofitaSyscalls::Noop) {
					volatile let syscall = process->syscallToHandle;
					process->syscallToHandle = TofitaSyscalls::Noop;
					volatile var frame = &process->frame;

					// Select pml4 to work within current process memory
					// Remember pml4 for proper restore from scheduling
					pml4kernelThread = process->pml4;
					amd64::writeCr3((uint64_t)pml4kernelThread - (uint64_t)WholePhysicalStart);

					// TODO refactor to separate syscall handler per-DLL

					if (syscall == TofitaSyscalls::DebugLog) {
						if (process->is64bit) {
							serialPrintf(L"[[DebugLog:PID %d]] ", index);
						} else {
							serialPrintf(L"[[DebugLog:PID %d (32-bit)]] ", index);
						}
						serialPrintf(L"[[rcx=%u rdx=%u r8=%u]] ", frame->rcxArg0, frame->rdxArg1, frame->r8);

						if (probeForReadOkay(frame->rdxArg1, sizeof(DebugLogPayload))) {
							DebugLogPayload *payload = (DebugLogPayload *)frame->rdxArg1;
							// Note this is still very unsafe
							if (probeForReadOkay((uint64_t)payload->message, 1)) {
								serialPrintf(payload->message, payload->extra, payload->more);
							}
						}

						serialPrintf(L"\n");
						process->schedulable = true;
					} else if (syscall == TofitaSyscalls::ExitProcess) {
						serialPrintf(L"[[ExitProcess:PID %d]] %d\n", index, frame->rdxArg1);
						process->present = false;

						// Select pml4 of idle process for safety
						pml4kernelThread = process::processes[0].pml4;
						amd64::writeCr3((uint64_t)pml4kernelThread - (uint64_t)WholePhysicalStart);

						// Deallocate process
						process::Process_destroy(process);
					} else if (syscall == TofitaSyscalls::Cpu) {
						serialPrintf(L"[[Cpu:PID %d]] %d\n", index, frame->rdxArg1);
						quakePrintf(L"Process #%d closed due to CPU exception #%u\n", index, frame->index);
						process->present = false;

						// Page fault
						if (frame->index == 0x0E)
							quakePrintf(L"#PF CR2 %8, IP %8\n", process->cr2PageFaultAddress, frame->ip);
						if (frame->index == 0x0D)
							quakePrintf(L"#GPF IP %8\n", frame->ip);
						if (frame->index == 0x03)
							quakePrintf(L"#BP IP %8\n", frame->ip);

						// Select pml4 of idle process for safety
						pml4kernelThread = process::processes[0].pml4;
						amd64::writeCr3((uint64_t)pml4kernelThread - (uint64_t)WholePhysicalStart);

						// Deallocate process
						process::Process_destroy(process);
					} else {
						frame->raxReturn = 0; // Must return at least something
						// Note ^ some code in syscall handlers may *read* this value
						// So set it to zero just in case

						if (!userCall::userCallHandled(process, syscall)) {
							// Unknown syscall is no-op
							serialPrintf(L"[[PID %d]] Unknown or unhandled syscall %d\n", index,
										 frame->rcxArg0);
							frame->raxReturn = 0;
							process->schedulable = true;
						}
					}
				}
			}
			index++;
		}

		switchToUserProcess();
	}
}
#endif

#define HEAP_ZERO_MEMORY 0
#define stdout 0
#define HANDLE void*

static void ExitProcess(int32_t x) {
	// Stub
}

static void wprintf(const wchar_t* x, const void* y) {
	serialPrintf(x, y);
}

static uint32_t strlen(const char *x) {
	return kstrlen((const uint8_t *)x);
}

#define macro_serialPrintf(print_, ...) serialPrintf((const wchar_t *)print_->_->utf16_(print_), ## __VA_ARGS__)

#define HEAP_C 2097152
static uint8_t heapInitial[HEAP_C] = {0};
static uint8_t* heap = nullptr;
static uint64_t heapOffset = 0;
static void* HeapAllocAt(size_t lineNumber, char const* filename, char const* functionName, int8_t x,int8_t u, uint64_t size) {
	// serialPrintf(L"HeapAlloc [%s:%d] %d", /*filename,*/ functionName, lineNumber, size);
	// size = ((size - 1) | 7) + 1; // Align by 8
	size = ((size - 1) | 15) + 1; // Align by 16
	if (size < 16) size = 16;
	heapOffset += 16;
	heapOffset += size;
	if (heapOffset >= HEAP_C) {
		serialPrint(L"Heap overflow\n");
		heap = (uint8_t*)PhysicalAllocator_$allocateBytes_(HEAP_C);
		heapOffset = 16 + size;
		while (heap == nullptr) {
			serialPrint(L"Heap total overflow\n");
		};
	}
	// TODO FILL WITH ZEROS RIGHT HERE!
	return &heap[heapOffset - size];
}
#define HeapAlloc(a, b, c) HeapAllocAt(__LINE__, __FILE__, __func__, a, b, c)
#define TRACER() serialPrintf(L"[%s:%d]\n", __func__, __LINE__)

#define HEXA_UNREACHABLE(where) {}

#define WriteFile(x,y,z,t,r) {}
#define FlushFileBuffers(x) {}
#define GetStdHandle(x) 0

#define GetProcessHeap() 0
#define DWORD uint32_t
#define HEXA_NO_DEFAULT_INCLUDES

#define ArrayByValue_$uint8_t$Any_ void
#define ArrayByValue_$uint32_t$Any_ void
#define ArrayByValue_$IdtEntry_$Any_ void
#define Virtual_$Any_ Any_
#define Physical_$Any_ Any_

#include "../kernel-diff/kernel.c"

externC function kernelMain(/*const TODO*/void *params) {
	kernelParams = (UefiPayload_ *)params;
	heap = &heapInitial[0];
	HEXA_MAIN(0, nullptr);
}
